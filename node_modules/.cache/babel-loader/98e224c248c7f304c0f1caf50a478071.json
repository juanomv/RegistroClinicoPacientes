{"ast":null,"code":"import { useMemo, createElement, useContext, createContext, version as version$1, Fragment, useReducer, useEffect, Suspense, useLayoutEffect } from 'react';\nimport { user } from 'rxfire/auth';\nimport { from, of, empty, Subject } from 'rxjs';\nimport { switchMap, map, tap, catchError, shareReplay, first } from 'rxjs/operators';\nimport { getApps, registerVersion, initializeApp } from 'firebase/app';\nimport { object, objectVal, list, listVal } from 'rxfire/database';\nimport { doc, docData, fromRef, collectionData } from 'rxfire/firestore';\nimport { queryEqual } from 'firebase/firestore';\nimport { httpsCallable } from 'rxfire/functions';\nimport { getValue, getString, getNumber, getBoolean, getAll } from 'rxfire/remote-config';\nimport { fromTask, getDownloadURL } from 'rxfire/storage';\nimport { ref } from 'firebase/storage';\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar runtime_1 = createCommonjsModule(function (module) {\n  /**\n   * Copyright (c) 2014-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n  var runtime = function (exports) {\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var undefined$1; // More compressible than void 0.\n\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n    function define(obj, key, value) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n      return obj[key];\n    }\n\n    try {\n      // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n      define({}, \"\");\n    } catch (err) {\n      define = function (obj, key, value) {\n        return obj[key] = value;\n      };\n    }\n\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n      var generator = Object.create(protoGenerator.prototype);\n      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n      // .throw, and .return methods.\n\n      generator._invoke = makeInvokeMethod(innerFn, self, context);\n      return generator;\n    }\n\n    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n\n    function tryCatch(fn, obj, arg) {\n      try {\n        return {\n          type: \"normal\",\n          arg: fn.call(obj, arg)\n        };\n      } catch (err) {\n        return {\n          type: \"throw\",\n          arg: err\n        };\n      }\n    }\n\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n\n    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n\n    function Generator() {}\n\n    function GeneratorFunction() {}\n\n    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n\n\n    var IteratorPrototype = {};\n    define(IteratorPrototype, iteratorSymbol, function () {\n      return this;\n    });\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n      // This environment has a native %IteratorPrototype%; use it instead\n      // of the polyfill.\n      IteratorPrototype = NativeIteratorPrototype;\n    }\n\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = GeneratorFunctionPrototype;\n    define(Gp, \"constructor\", GeneratorFunctionPrototype);\n    define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"); // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n\n    function defineIteratorMethods(prototype) {\n      [\"next\", \"throw\", \"return\"].forEach(function (method) {\n        define(prototype, method, function (arg) {\n          return this._invoke(method, arg);\n        });\n      });\n    }\n\n    exports.isGeneratorFunction = function (genFun) {\n      var ctor = typeof genFun === \"function\" && genFun.constructor;\n      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n      // do is to check its .name property.\n      (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n\n    exports.mark = function (genFun) {\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n      } else {\n        genFun.__proto__ = GeneratorFunctionPrototype;\n        define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n      }\n\n      genFun.prototype = Object.create(Gp);\n      return genFun;\n    }; // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n\n\n    exports.awrap = function (arg) {\n      return {\n        __await: arg\n      };\n    };\n\n    function AsyncIterator(generator, PromiseImpl) {\n      function invoke(method, arg, resolve, reject) {\n        var record = tryCatch(generator[method], generator, arg);\n\n        if (record.type === \"throw\") {\n          reject(record.arg);\n        } else {\n          var result = record.arg;\n          var value = result.value;\n\n          if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n            return PromiseImpl.resolve(value.__await).then(function (value) {\n              invoke(\"next\", value, resolve, reject);\n            }, function (err) {\n              invoke(\"throw\", err, resolve, reject);\n            });\n          }\n\n          return PromiseImpl.resolve(value).then(function (unwrapped) {\n            // When a yielded Promise is resolved, its final value becomes\n            // the .value of the Promise<{value,done}> result for the\n            // current iteration.\n            result.value = unwrapped;\n            resolve(result);\n          }, function (error) {\n            // If a rejected Promise was yielded, throw the rejection back\n            // into the async generator function so it can be handled there.\n            return invoke(\"throw\", error, resolve, reject);\n          });\n        }\n      }\n\n      var previousPromise;\n\n      function enqueue(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n\n        return previousPromise = // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n        // invocations of the iterator.\n        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      } // Define the unified helper method that is used to implement .next,\n      // .throw, and .return (see defineIteratorMethods).\n\n\n      this._invoke = enqueue;\n    }\n\n    defineIteratorMethods(AsyncIterator.prototype);\n    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n      return this;\n    });\n    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n\n    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n      if (PromiseImpl === void 0) PromiseImpl = Promise;\n      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function (result) {\n        return result.done ? result.value : iter.next();\n      });\n    };\n\n    function makeInvokeMethod(innerFn, self, context) {\n      var state = GenStateSuspendedStart;\n      return function invoke(method, arg) {\n        if (state === GenStateExecuting) {\n          throw new Error(\"Generator is already running\");\n        }\n\n        if (state === GenStateCompleted) {\n          if (method === \"throw\") {\n            throw arg;\n          } // Be forgiving, per 25.3.3.3.3 of the spec:\n          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n          return doneResult();\n        }\n\n        context.method = method;\n        context.arg = arg;\n\n        while (true) {\n          var delegate = context.delegate;\n\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (context.method === \"next\") {\n            // Setting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            context.sent = context._sent = context.arg;\n          } else if (context.method === \"throw\") {\n            if (state === GenStateSuspendedStart) {\n              state = GenStateCompleted;\n              throw context.arg;\n            }\n\n            context.dispatchException(context.arg);\n          } else if (context.method === \"return\") {\n            context.abrupt(\"return\", context.arg);\n          }\n\n          state = GenStateExecuting;\n          var record = tryCatch(innerFn, self, context);\n\n          if (record.type === \"normal\") {\n            // If an exception is thrown from innerFn, we leave state ===\n            // GenStateExecuting and loop back for another invocation.\n            state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n            if (record.arg === ContinueSentinel) {\n              continue;\n            }\n\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          } else if (record.type === \"throw\") {\n            state = GenStateCompleted; // Dispatch the exception by looping back around to the\n            // context.dispatchException(context.arg) call above.\n\n            context.method = \"throw\";\n            context.arg = record.arg;\n          }\n        }\n      };\n    } // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n    function maybeInvokeDelegate(delegate, context) {\n      var method = delegate.iterator[context.method];\n\n      if (method === undefined$1) {\n        // A .throw or .return when the delegate iterator has no .throw\n        // method always terminates the yield* loop.\n        context.delegate = null;\n\n        if (context.method === \"throw\") {\n          // Note: [\"return\"] must be used for ES3 parsing compatibility.\n          if (delegate.iterator[\"return\"]) {\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            context.method = \"return\";\n            context.arg = undefined$1;\n            maybeInvokeDelegate(delegate, context);\n\n            if (context.method === \"throw\") {\n              // If maybeInvokeDelegate(context) changed context.method from\n              // \"return\" to \"throw\", let that override the TypeError below.\n              return ContinueSentinel;\n            }\n          }\n\n          context.method = \"throw\";\n          context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n        }\n\n        return ContinueSentinel;\n      }\n\n      var record = tryCatch(method, delegate.iterator, context.arg);\n\n      if (record.type === \"throw\") {\n        context.method = \"throw\";\n        context.arg = record.arg;\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      var info = record.arg;\n\n      if (!info) {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"iterator result is not an object\");\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      if (info.done) {\n        // Assign the result of the finished delegate to the temporary\n        // variable specified by delegate.resultName (see delegateYield).\n        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n        context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n        // exception, let the outer generator proceed normally. If\n        // context.method was \"next\", forget context.arg since it has been\n        // \"consumed\" by the delegate iterator. If context.method was\n        // \"return\", allow the original .return call to continue in the\n        // outer generator.\n\n        if (context.method !== \"return\") {\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n      } else {\n        // Re-yield the result returned by the delegate method.\n        return info;\n      } // The delegate iterator is finished, so forget it and continue with\n      // the outer generator.\n\n\n      context.delegate = null;\n      return ContinueSentinel;\n    } // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n\n\n    defineIteratorMethods(Gp);\n    define(Gp, toStringTagSymbol, \"Generator\"); // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n    define(Gp, iteratorSymbol, function () {\n      return this;\n    });\n    define(Gp, \"toString\", function () {\n      return \"[object Generator]\";\n    });\n\n    function pushTryEntry(locs) {\n      var entry = {\n        tryLoc: locs[0]\n      };\n\n      if (1 in locs) {\n        entry.catchLoc = locs[1];\n      }\n\n      if (2 in locs) {\n        entry.finallyLoc = locs[2];\n        entry.afterLoc = locs[3];\n      }\n\n      this.tryEntries.push(entry);\n    }\n\n    function resetTryEntry(entry) {\n      var record = entry.completion || {};\n      record.type = \"normal\";\n      delete record.arg;\n      entry.completion = record;\n    }\n\n    function Context(tryLocsList) {\n      // The root entry object (effectively a try statement without a catch\n      // or a finally block) gives us a place to store values thrown from\n      // locations where there is no enclosing try statement.\n      this.tryEntries = [{\n        tryLoc: \"root\"\n      }];\n      tryLocsList.forEach(pushTryEntry, this);\n      this.reset(true);\n    }\n\n    exports.keys = function (object) {\n      var keys = [];\n\n      for (var key in object) {\n        keys.push(key);\n      }\n\n      keys.reverse(); // Rather than returning an object with a next method, we keep\n      // things simple and return the next function itself.\n\n      return function next() {\n        while (keys.length) {\n          var key = keys.pop();\n\n          if (key in object) {\n            next.value = key;\n            next.done = false;\n            return next;\n          }\n        } // To avoid creating an additional object, we just hang the .value\n        // and .done properties off the next function object itself. This\n        // also ensures that the minifier will not anonymize the function.\n\n\n        next.done = true;\n        return next;\n      };\n    };\n\n    function values(iterable) {\n      if (iterable) {\n        var iteratorMethod = iterable[iteratorSymbol];\n\n        if (iteratorMethod) {\n          return iteratorMethod.call(iterable);\n        }\n\n        if (typeof iterable.next === \"function\") {\n          return iterable;\n        }\n\n        if (!isNaN(iterable.length)) {\n          var i = -1,\n              next = function next() {\n            while (++i < iterable.length) {\n              if (hasOwn.call(iterable, i)) {\n                next.value = iterable[i];\n                next.done = false;\n                return next;\n              }\n            }\n\n            next.value = undefined$1;\n            next.done = true;\n            return next;\n          };\n\n          return next.next = next;\n        }\n      } // Return an iterator with no values.\n\n\n      return {\n        next: doneResult\n      };\n    }\n\n    exports.values = values;\n\n    function doneResult() {\n      return {\n        value: undefined$1,\n        done: true\n      };\n    }\n\n    Context.prototype = {\n      constructor: Context,\n      reset: function (skipTempReset) {\n        this.prev = 0;\n        this.next = 0; // Resetting context._sent for legacy support of Babel's\n        // function.sent implementation.\n\n        this.sent = this._sent = undefined$1;\n        this.done = false;\n        this.delegate = null;\n        this.method = \"next\";\n        this.arg = undefined$1;\n        this.tryEntries.forEach(resetTryEntry);\n\n        if (!skipTempReset) {\n          for (var name in this) {\n            // Not sure about the optimal order of these conditions:\n            if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n              this[name] = undefined$1;\n            }\n          }\n        }\n      },\n      stop: function () {\n        this.done = true;\n        var rootEntry = this.tryEntries[0];\n        var rootRecord = rootEntry.completion;\n\n        if (rootRecord.type === \"throw\") {\n          throw rootRecord.arg;\n        }\n\n        return this.rval;\n      },\n      dispatchException: function (exception) {\n        if (this.done) {\n          throw exception;\n        }\n\n        var context = this;\n\n        function handle(loc, caught) {\n          record.type = \"throw\";\n          record.arg = exception;\n          context.next = loc;\n\n          if (caught) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            context.method = \"next\";\n            context.arg = undefined$1;\n          }\n\n          return !!caught;\n        }\n\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          var record = entry.completion;\n\n          if (entry.tryLoc === \"root\") {\n            // Exception thrown outside of any try block that could handle\n            // it, so set the completion value of the entire function to\n            // throw the exception.\n            return handle(\"end\");\n          }\n\n          if (entry.tryLoc <= this.prev) {\n            var hasCatch = hasOwn.call(entry, \"catchLoc\");\n            var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n            if (hasCatch && hasFinally) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              } else if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else if (hasCatch) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              }\n            } else if (hasFinally) {\n              if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else {\n              throw new Error(\"try statement without catch or finally\");\n            }\n          }\n        }\n      },\n      abrupt: function (type, arg) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n            var finallyEntry = entry;\n            break;\n          }\n        }\n\n        if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n          // Ignore the finally entry if control is not jumping to a\n          // location outside the try/catch block.\n          finallyEntry = null;\n        }\n\n        var record = finallyEntry ? finallyEntry.completion : {};\n        record.type = type;\n        record.arg = arg;\n\n        if (finallyEntry) {\n          this.method = \"next\";\n          this.next = finallyEntry.finallyLoc;\n          return ContinueSentinel;\n        }\n\n        return this.complete(record);\n      },\n      complete: function (record, afterLoc) {\n        if (record.type === \"throw\") {\n          throw record.arg;\n        }\n\n        if (record.type === \"break\" || record.type === \"continue\") {\n          this.next = record.arg;\n        } else if (record.type === \"return\") {\n          this.rval = this.arg = record.arg;\n          this.method = \"return\";\n          this.next = \"end\";\n        } else if (record.type === \"normal\" && afterLoc) {\n          this.next = afterLoc;\n        }\n\n        return ContinueSentinel;\n      },\n      finish: function (finallyLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.finallyLoc === finallyLoc) {\n            this.complete(entry.completion, entry.afterLoc);\n            resetTryEntry(entry);\n            return ContinueSentinel;\n          }\n        }\n      },\n      \"catch\": function (tryLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc === tryLoc) {\n            var record = entry.completion;\n\n            if (record.type === \"throw\") {\n              var thrown = record.arg;\n              resetTryEntry(entry);\n            }\n\n            return thrown;\n          }\n        } // The context.catch method must only be called with a location\n        // argument that corresponds to a known catch block.\n\n\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function (iterable, resultName, nextLoc) {\n        this.delegate = {\n          iterator: values(iterable),\n          resultName: resultName,\n          nextLoc: nextLoc\n        };\n\n        if (this.method === \"next\") {\n          // Deliberately forget the last sent value so that we don't\n          // accidentally pass it on to the delegate.\n          this.arg = undefined$1;\n        }\n\n        return ContinueSentinel;\n      }\n    }; // Regardless of whether this script is executing as a CommonJS module\n    // or not, return the runtime object so that we can declare the variable\n    // regeneratorRuntime in the outer scope, which allows this module to be\n    // injected easily by `bin/regenerator --include-runtime script.js`.\n\n    return exports;\n  }( // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  module.exports);\n\n  try {\n    regeneratorRuntime = runtime;\n  } catch (accidentalStrictMode) {\n    // This module should not be running in strict mode, so the above\n    // assignment should always work unless something is misconfigured. Just\n    // in case runtime.js accidentally runs in strict mode, in modern engines\n    // we can explicitly access globalThis. In older engines we can escape\n    // strict mode using a global Function call. This could conceivably fail\n    // if a Content Security Policy forbids using Function, but in that case\n    // the proper solution is to fix the accidental strict mode problem. If\n    // you've misconfigured your bundler to force strict mode and applied a\n    // CSP to forbid Function, and you're not willing to fix either of those\n    // problems, please detail your unique predicament in a GitHub issue.\n    if (typeof globalThis === \"object\") {\n      globalThis.regeneratorRuntime = runtime;\n    } else {\n      Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n    }\n  }\n});\nvar DEFAULT_APP_NAME = '[DEFAULT]';\nvar FirebaseAppContext = /*#__PURE__*/createContext(undefined);\nvar SuspenseEnabledContext = /*#__PURE__*/createContext(false); // @ts-expect-error: \"__REACTFIRE_VERSION__\" is replaced with actual ReactFire version (see babel.config.js)\n\nvar version = \"4.2.0\";\n\nvar shallowEq = function shallowEq(a, b) {\n  return a === b || [].concat(Object.keys(a), Object.keys(b)).every(function (key) {\n    return a[key] === b[key];\n  });\n};\n\nfunction FirebaseAppProvider(props) {\n  var firebaseConfig = props.firebaseConfig,\n      appName = props.appName,\n      suspense = props.suspense;\n  var firebaseApp = useMemo(function () {\n    if (props.firebaseApp) {\n      return props.firebaseApp;\n    }\n\n    var existingApp = getApps().find(function (app) {\n      return app.name === (appName || DEFAULT_APP_NAME);\n    });\n\n    if (existingApp) {\n      if (firebaseConfig && shallowEq(existingApp.options, firebaseConfig)) {\n        return existingApp;\n      } else {\n        throw new Error(\"Does not match the options already provided to the \" + (appName || 'default') + \" firebase app instance, give this new instance a different appName.\");\n      }\n    } else {\n      if (!firebaseConfig) {\n        throw new Error('No firebaseConfig provided');\n      }\n\n      var reactVersion = version$1 || 'unknown';\n      registerVersion('react', reactVersion);\n      registerVersion('reactfire', version);\n      return initializeApp(firebaseConfig, appName);\n    }\n  }, [props.firebaseApp, firebaseConfig, appName]);\n  return createElement(FirebaseAppContext.Provider, {\n    value: firebaseApp\n  }, createElement(SuspenseEnabledContext.Provider, _extends({\n    value: suspense != null ? suspense : false\n  }, props)));\n}\n\nfunction useIsSuspenseEnabled() {\n  var suspense = useContext(SuspenseEnabledContext); // default to false if not available in context\n\n  return suspense != null ? suspense : false;\n}\n\nfunction useSuspenseEnabledFromConfigAndContext(suspenseFromConfig) {\n  var suspenseFromContext = useContext(SuspenseEnabledContext); // prioritize config over context\n\n  if (suspenseFromConfig !== undefined) {\n    return suspenseFromConfig;\n  }\n\n  return suspenseFromContext;\n}\n\nfunction useFirebaseApp() {\n  var firebaseApp = useContext(FirebaseAppContext);\n\n  if (!firebaseApp) {\n    throw new Error('Cannot call useFirebaseApp unless your component is within a FirebaseAppProvider');\n  }\n\n  return firebaseApp;\n}\n\nfunction preloadUser(_x) {\n  return _preloadUser.apply(this, arguments);\n}\n/**\r\n * Subscribe to Firebase auth state changes, including token refresh\r\n *\r\n * @param options\r\n */\n\n\nfunction _preloadUser() {\n  _preloadUser = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(authResolver) {\n    var auth, user$;\n    return runtime_1.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return authResolver();\n\n          case 2:\n            auth = _context.sent;\n            user$ = preloadObservable(user(auth), \"auth:user:\" + auth.name);\n            return _context.abrupt(\"return\", user$.toPromise());\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _preloadUser.apply(this, arguments);\n}\n\nfunction useUser(options) {\n  var _options$initialData;\n\n  var auth = useAuth();\n  var observableId = \"auth:user:\" + auth.name;\n  var observable$ = user(auth);\n  var currentUser = auth.currentUser; // Only use options.initialData if auth.currentUser is unavailable\n\n  if (!currentUser && ((_options$initialData = options == null ? void 0 : options.initialData) != null ? _options$initialData : options == null ? void 0 : options.startWithValue)) {\n    var _options$initialData2;\n\n    currentUser = (_options$initialData2 = options.initialData) != null ? _options$initialData2 : options.startWithValue;\n  }\n\n  return useObservable(observableId, observable$, _extends({}, options, {\n    initialData: currentUser\n  }));\n}\n\nfunction useIdTokenResult(user, forceRefresh, options) {\n  if (forceRefresh === void 0) {\n    forceRefresh = false;\n  }\n\n  if (!user) {\n    throw new Error('you must provide a user');\n  }\n\n  var observableId = \"auth:idTokenResult:\" + user.uid + \":forceRefresh=\" + forceRefresh;\n  var observable$ = from(user.getIdTokenResult(forceRefresh));\n  return useObservable(observableId, observable$, options);\n}\n/**\r\n * Subscribe to the signed-in status of a user.\r\n *\r\n * ```ts\r\n * const { status, data:signInCheckResult } = useSigninCheck();\r\n *\r\n * if (status === 'loading') {\r\n *   return <LoadingSpinner />}\r\n *\r\n *\r\n * if (signInCheckResult.signedIn === true) {\r\n *   return <ProfilePage user={signInCheckResult.user}/>\r\n * } else {\r\n *   return <SignInForm />\r\n * }\r\n * ```\r\n *\r\n * Optionally check [custom claims](https://firebase.google.com/docs/auth/admin/custom-claims) of a user as well.\r\n *\r\n * ```ts\r\n * // pass in an object describing the custom claims a user must have\r\n * const {status, data: signInCheckResult} = useSignInCheck({requiredClaims: {admin: true}});\r\n *\r\n * // pass in a custom claims validator function\r\n * const {status, data: signInCheckResult} = useSignInCheck({validateCustomClaims: (userClaims) => {\r\n *   // custom validation logic...\r\n * }});\r\n *\r\n * // You can optionally force-refresh the token\r\n * const {status, data: signInCheckResult} = useSignInCheck({forceRefresh: true, requiredClaims: {admin: true}});\r\n * ```\r\n */\n\n\nfunction useSigninCheck(options) {\n  // If both `requiredClaims` and `validateCustomClaims` are provided, we won't know which one to use\n  if (options != null && options.hasOwnProperty('requiredClaims') && options != null && options.hasOwnProperty('validateCustomClaims')) {\n    throw new Error('Cannot have both \"requiredClaims\" and \"validateCustomClaims\". Use one or the other.');\n  }\n\n  var auth = useAuth(); // ObservableId should change for different options configurations to ensure no cache collisions\n\n  var observableId = \"auth:signInCheck:\" + auth.name + \"::forceRefresh:\" + !!(options != null && options.forceRefresh);\n\n  if (options != null && options.forceRefresh) {\n    observableId = observableId + \":forceRefresh:\" + options.forceRefresh;\n  }\n\n  if (options != null && options.hasOwnProperty('requiredClaims')) {\n    observableId = observableId + \":requiredClaims:\" + JSON.stringify(options.requiredClaims);\n  } else if (options != null && options.hasOwnProperty('validateCustomClaims')) {\n    // TODO(jamesdaniels): Check if stringifying this function breaks in IE11\n    observableId = observableId + \":validateCustomClaims:\" + JSON.stringify(options.validateCustomClaims);\n  }\n\n  var observable = user(auth).pipe(switchMap(function (user) {\n    if (!user) {\n      var result = {\n        signedIn: false,\n        hasRequiredClaims: false,\n        errors: {},\n        user: null\n      };\n      return of(result);\n    } else if (options && (options.hasOwnProperty('requiredClaims') || options.hasOwnProperty('validateCustomClaims'))) {\n      var _options$forceRefresh;\n\n      return from(user.getIdTokenResult((_options$forceRefresh = options == null ? void 0 : options.forceRefresh) != null ? _options$forceRefresh : false)).pipe(map(function (idTokenResult) {\n        var validator;\n\n        if (options.hasOwnProperty('requiredClaims')) {\n          validator = getClaimsObjectValidator(options.requiredClaims);\n        } else {\n          validator = options.validateCustomClaims;\n        }\n\n        var _validator = validator(idTokenResult.claims),\n            hasRequiredClaims = _validator.hasRequiredClaims,\n            errors = _validator.errors;\n\n        var result = {\n          signedIn: true,\n          hasRequiredClaims: hasRequiredClaims,\n          errors: errors,\n          user: user\n        };\n        return result;\n      }));\n    } else {\n      // If no claims are provided to be checked, `hasRequiredClaims` is true\n      var _result = {\n        signedIn: true,\n        hasRequiredClaims: true,\n        errors: {},\n        user: user\n      };\n      return of(_result);\n    }\n  }));\n  return useObservable(observableId, observable);\n}\n\nfunction getClaimsObjectValidator(requiredClaims) {\n  return function claimsObjectValidator(userClaims) {\n    var errors = {};\n    Object.keys(requiredClaims).forEach(function (claim) {\n      if (requiredClaims[claim] !== userClaims[claim]) {\n        errors[claim] = [new ReactFireError('auth/missing-claim', \"Expected \\\"\" + requiredClaims[claim] + \"\\\", but user has \\\"\" + userClaims[claim] + \"\\\" instead\")];\n      }\n    });\n    return {\n      hasRequiredClaims: Object.keys(errors).length === 0,\n      errors: errors\n    };\n  };\n}\n/**\r\n * @deprecated Use `useSignInCheck` instead\r\n *\r\n * Conditionally render children based on [custom claims](https://firebase.google.com/docs/auth/admin/custom-claims).\r\n *\r\n * Meant for Concurrent mode only (`<FirebaseAppProvider suspense=true />`). [More detail](https://github.com/FirebaseExtended/reactfire/issues/325#issuecomment-827654376).\r\n */\n\n\nfunction ClaimsCheck(_ref) {\n  var user = _ref.user,\n      fallback = _ref.fallback,\n      children = _ref.children,\n      requiredClaims = _ref.requiredClaims;\n\n  var _useIdTokenResult = useIdTokenResult(user, false),\n      data = _useIdTokenResult.data;\n\n  var claims = data.claims;\n  var missingClaims = {};\n  var suspenseMode = useSuspenseEnabledFromConfigAndContext();\n\n  if (!suspenseMode) {\n    console.warn('ClaimsCheck is deprecated and only works when ReactFire is in experimental Suspense Mode. Use useSigninCheck or set suspense={true} in FirebaseAppProvider if you want to use this component.');\n  }\n\n  if (requiredClaims) {\n    Object.keys(requiredClaims).forEach(function (claim) {\n      if (requiredClaims[claim] !== claims[claim]) {\n        var _claims$claim;\n\n        missingClaims[claim] = {\n          expected: requiredClaims[claim],\n          actual: (_claims$claim = claims[claim]) == null ? void 0 : _claims$claim.toString()\n        };\n      }\n    });\n  }\n\n  if (Object.keys(missingClaims).length === 0) {\n    return createElement(Fragment, null, children);\n  } else {\n    return createElement(Fragment, null, fallback);\n  }\n}\n/**\r\n * @deprecated Use `useSignInCheck` instead\r\n *\r\n * Conditionally render children based on signed-in status and [custom claims](https://firebase.google.com/docs/auth/admin/custom-claims).\r\n *\r\n * Meant for Concurrent mode only (`<FirebaseAppProvider suspense=true />`). [More detail](https://github.com/FirebaseExtended/reactfire/issues/325#issuecomment-827654376).\r\n */\n\n\nfunction AuthCheck(_ref2) {\n  var fallback = _ref2.fallback,\n      children = _ref2.children,\n      requiredClaims = _ref2.requiredClaims;\n\n  var _useUser = useUser(),\n      user = _useUser.data;\n\n  var suspenseMode = useSuspenseEnabledFromConfigAndContext();\n\n  if (!suspenseMode) {\n    console.warn('AuthCheck is deprecated and only works when ReactFire is in experimental Suspense Mode. Use useSigninCheck or set suspense={true} in FirebaseAppProvider if you want to use this component.');\n  }\n\n  if (user) {\n    return requiredClaims ? createElement(ClaimsCheck, {\n      user: user,\n      fallback: fallback,\n      requiredClaims: requiredClaims\n    }, children) : createElement(Fragment, null, children);\n  } else {\n    return createElement(Fragment, null, fallback);\n  }\n}\n\nvar cachedQueries = globalThis._reactFireDatabaseCachedQueries || [];\n\nif (!globalThis._reactFireDatabaseCachedQueries) {\n  globalThis._reactFireDatabaseCachedQueries = cachedQueries;\n}\n\nfunction getUniqueIdForDatabaseQuery(query) {\n  var index = cachedQueries.findIndex(function (cachedQuery) {\n    return cachedQuery.isEqual(query);\n  });\n\n  if (index > -1) {\n    return index;\n  }\n\n  return cachedQueries.push(query) - 1;\n}\n/**\r\n * Subscribe to a Realtime Database object\r\n *\r\n * @param ref - Reference to the DB object you want to listen to\r\n * @param options\r\n */\n\n\nfunction useDatabaseObject(ref, options) {\n  var observableId = \"database:object:\" + ref.toString();\n  var observable$ = object(ref);\n  return useObservable(observableId, observable$, options);\n}\n\nfunction useDatabaseObjectData(ref, options) {\n  var idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  var observableId = \"database:objectVal:\" + ref.toString() + \":idField=\" + idField;\n  var observable$ = objectVal(ref, {\n    keyField: idField\n  });\n  return useObservable(observableId, observable$, options);\n}\n/**\r\n * Subscribe to a Realtime Database list\r\n *\r\n * @param ref - Reference to the DB List you want to listen to\r\n * @param options\r\n */\n\n\nfunction useDatabaseList(ref, options) {\n  var hash = \"database:list:\" + getUniqueIdForDatabaseQuery(ref);\n  var observable$ = list(ref);\n  return useObservable(hash, observable$, options);\n}\n\nfunction useDatabaseListData(ref, options) {\n  var idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  var observableId = \"database:listVal:\" + getUniqueIdForDatabaseQuery(ref) + \":idField=\" + idField;\n  var observable$ = listVal(ref, {\n    keyField: idField\n  });\n  return useObservable(observableId, observable$, options);\n}\n\nvar SuspenseSubject = /*#__PURE__*/function (_Subject) {\n  _inheritsLoose(SuspenseSubject, _Subject); // @ts-expect-error: TODO: double check to see if this is an RXJS thing or if we should listen to TS\n  // @ts-expect-error: TODO: double check to see if this is an RXJS thing or if we should listen to TS\n\n\n  function SuspenseSubject(innerObservable, _timeoutWindow) {\n    var _this;\n\n    _this = _Subject.call(this) || this;\n    _this._timeoutWindow = void 0;\n    _this._value = void 0;\n    _this._hasValue = false;\n    _this._timeoutHandler = void 0;\n    _this._firstEmission = void 0;\n    _this._error = undefined;\n    _this._innerObservable = void 0;\n    _this._warmupSubscription = void 0;\n    _this._innerSubscriber = void 0;\n    _this._resolveFirstEmission = void 0;\n    _this._timeoutWindow = _timeoutWindow;\n    _this._firstEmission = new Promise(function (resolve) {\n      return _this._resolveFirstEmission = resolve;\n    });\n    _this._innerObservable = innerObservable.pipe(tap({\n      next: function next(v) {\n        _this._next(v);\n      },\n      error: function error(e) {\n        // save the error, so that we can raise on subscription or .value\n        // resolve the promise, so suspense tries again\n        _this._error = e;\n\n        _this._resolveFirstEmission();\n      }\n    }), catchError(function () {\n      return empty();\n    }), shareReplay(1)); // warm up the observable\n\n    _this._warmupSubscription = _this._innerObservable.subscribe(); // set a timeout for resetting the cache, subscriptions will cancel the timeout\n    // and reschedule again on unsubscribe\n\n    _this._timeoutHandler = setTimeout(_this._reset.bind(_assertThisInitialized(_this)), _this._timeoutWindow);\n    return _this;\n  }\n\n  var _proto = SuspenseSubject.prototype;\n\n  _proto._next = function _next(value) {\n    this._hasValue = true;\n    this._value = value;\n\n    this._resolveFirstEmission();\n  };\n\n  _proto._reset = function _reset() {\n    var _this2 = this; // seems to be undefined in tests?\n\n\n    if (this._warmupSubscription) {\n      this._warmupSubscription.unsubscribe();\n    }\n\n    this._hasValue = false;\n    this._value = undefined;\n    this._error = undefined;\n    this._firstEmission = new Promise(function (resolve) {\n      return _this2._resolveFirstEmission = resolve;\n    });\n  };\n\n  _proto._subscribe = function _subscribe(subscriber) {\n    if (this._timeoutHandler) {\n      clearTimeout(this._timeoutHandler);\n    }\n\n    this._innerSubscriber = this._innerObservable.subscribe(subscriber);\n    return this._innerSubscriber;\n  };\n\n  _createClass(SuspenseSubject, [{\n    key: \"hasValue\",\n    get: function get() {\n      // hasValue returns true if there's an error too\n      // so that after we resolve the promise & useObservable is called again\n      // we won't throw again\n      return this._hasValue || !!this._error;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      // TODO figure out how to reset the cache here, if I _reset() here before throwing\n      // it doesn't seem to work.\n      // As it is now, this will burn the cache entry until the timeout fires.\n      if (this._error) {\n        throw this._error;\n      } else if (!this.hasValue) {\n        throw Error('Can only get value if SuspenseSubject has a value');\n      }\n\n      return this._value;\n    }\n  }, {\n    key: \"firstEmission\",\n    get: function get() {\n      return this._firstEmission;\n    }\n  }, {\n    key: \"ourError\",\n    get: function get() {\n      return this._error;\n    }\n  }]);\n\n  return SuspenseSubject;\n}(Subject);\n\nvar DEFAULT_TIMEOUT = 30000; // Since we're side-effect free, we need to ensure our observable cache is global\n\nvar preloadedObservables = globalThis._reactFirePreloadedObservables || /*#__PURE__*/new Map();\n\nif (!globalThis._reactFirePreloadedObservables) {\n  globalThis._reactFirePreloadedObservables = preloadedObservables;\n} // Starts listening to an Observable.\n// Call this once you know you're going to render a\n// child that will consume the observable\n\n\nfunction preloadObservable(source, id) {\n  if (preloadedObservables.has(id)) {\n    return preloadedObservables.get(id);\n  } else {\n    var observable = new SuspenseSubject(source, DEFAULT_TIMEOUT);\n    preloadedObservables.set(id, observable);\n    return observable;\n  }\n}\n\nfunction reducerFactory(observable) {\n  return function reducer(state, action) {\n    // always make sure these values are in sync with the observable\n    var newState = _extends({}, state, {\n      hasEmitted: state.hasEmitted || observable.hasValue,\n      error: observable.ourError,\n      firstValuePromise: observable.firstEmission\n    });\n\n    if (observable.hasValue) {\n      newState.data = observable.value;\n    }\n\n    switch (action) {\n      case 'value':\n        newState.status = 'success';\n        return newState;\n\n      case 'error':\n        newState.status = 'error';\n        return newState;\n\n      case 'complete':\n        newState.isComplete = true;\n        return newState;\n\n      default:\n        throw new Error(\"invalid action \\\"\" + action + \"\\\"\");\n    }\n  };\n}\n\nfunction useObservable(observableId, source, config) {\n  var _config$initialData, _config, _config2;\n\n  if (config === void 0) {\n    config = {};\n  } // Register the observable with the cache\n\n\n  if (!observableId) {\n    throw new Error('cannot call useObservable without an observableId');\n  }\n\n  var observable = preloadObservable(source, observableId); // Suspend if suspense is enabled and no initial data exists\n\n  var hasInitialData = config.hasOwnProperty('initialData') || config.hasOwnProperty('startWithValue');\n  var hasData = observable.hasValue || hasInitialData;\n  var suspenseEnabled = useSuspenseEnabledFromConfigAndContext(config.suspense);\n\n  if (suspenseEnabled === true && !hasData) {\n    throw observable.firstEmission;\n  }\n\n  var initialState = {\n    status: hasData ? 'success' : 'loading',\n    hasEmitted: hasData,\n    isComplete: false,\n    data: observable.hasValue ? observable.value : (_config$initialData = (_config = config) == null ? void 0 : _config.initialData) != null ? _config$initialData : (_config2 = config) == null ? void 0 : _config2.startWithValue,\n    error: observable.ourError,\n    firstValuePromise: observable.firstEmission\n  };\n\n  var _React$useReducer = useReducer(reducerFactory(observable), initialState),\n      status = _React$useReducer[0],\n      dispatch = _React$useReducer[1];\n\n  useEffect(function () {\n    var subscription = observable.subscribe({\n      next: function next() {\n        dispatch('value');\n      },\n      error: function error(e) {\n        dispatch('error');\n        throw e;\n      },\n      complete: function complete() {\n        dispatch('complete');\n      }\n    });\n    return function () {\n      return subscription.unsubscribe();\n    };\n  }, [observable]);\n  return status;\n}\n\nvar cachedQueries$1 = globalThis._reactFireFirestoreQueryCache || [];\n\nif (!globalThis._reactFireFirestoreQueryCache) {\n  globalThis._reactFireFirestoreQueryCache = cachedQueries$1;\n}\n\nfunction getUniqueIdForFirestoreQuery(query) {\n  var index = cachedQueries$1.findIndex(function (cachedQuery) {\n    return queryEqual(cachedQuery, query);\n  });\n\n  if (index > -1) {\n    return index;\n  }\n\n  return cachedQueries$1.push(query) - 1;\n}\n/**\r\n * Preload a subscription to a Firestore document reference.\r\n *\r\n * Use this to warm up `useFirestoreDoc` for a specific document\r\n */\n\n\nfunction preloadFirestoreDoc(_x) {\n  return _preloadFirestoreDoc.apply(this, arguments);\n}\n\nfunction _preloadFirestoreDoc() {\n  _preloadFirestoreDoc = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(refProvider) {\n    var ref;\n    return runtime_1.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return refProvider();\n\n          case 2:\n            ref = _context.sent;\n            return _context.abrupt(\"return\", preloadObservable(doc(ref), getDocObservableId(ref)));\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _preloadFirestoreDoc.apply(this, arguments);\n}\n\nfunction getDocObservableId(ref) {\n  return \"firestore:doc:\" + ref.firestore.app.name + \":\" + ref.path;\n}\n/**\r\n * Suscribe to Firestore Document changes\r\n *\r\n * You can preload data for this hook by calling `preloadFirestoreDoc`\r\n */\n\n\nfunction useFirestoreDoc(ref, options) {\n  var observableId = getDocObservableId(ref);\n  var observable$ = doc(ref);\n  return useObservable(observableId, observable$, options);\n}\n/**\r\n * Get a firestore document and don't subscribe to changes\r\n */\n\n\nfunction useFirestoreDocOnce(ref, options) {\n  var observableId = \"firestore:docOnce:\" + ref.firestore.app.name + \":\" + ref.path;\n  var observable$ = doc(ref).pipe(first());\n  return useObservable(observableId, observable$, options);\n}\n/**\r\n * Suscribe to Firestore Document changes and unwrap the document into a plain object\r\n */\n\n\nfunction useFirestoreDocData(ref, options) {\n  var idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  var observableId = \"firestore:docData:\" + ref.firestore.app.name + \":\" + ref.path + \":idField=\" + idField;\n  var observable = docData(ref, {\n    idField: idField\n  });\n  return useObservable(observableId, observable, options);\n}\n/**\r\n * Get a Firestore document, unwrap the document into a plain object, and don't subscribe to changes\r\n */\n\n\nfunction useFirestoreDocDataOnce(ref, options) {\n  var idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  var observableId = \"firestore:docDataOnce:\" + ref.firestore.app.name + \":\" + ref.path + \":idField=\" + idField;\n  var observable$ = docData(ref, {\n    idField: idField\n  }).pipe(first());\n  return useObservable(observableId, observable$, options);\n}\n/**\r\n * Subscribe to a Firestore collection\r\n */\n\n\nfunction useFirestoreCollection(query, options) {\n  var observableId = \"firestore:collection:\" + getUniqueIdForFirestoreQuery(query);\n  var observable$ = fromRef(query);\n  return useObservable(observableId, observable$, options);\n}\n/**\r\n * Subscribe to a Firestore collection and unwrap the snapshot into an array.\r\n */\n\n\nfunction useFirestoreCollectionData(query, options) {\n  var idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  var observableId = \"firestore:collectionData:\" + getUniqueIdForFirestoreQuery(query) + \":idField=\" + idField;\n  var observable$ = collectionData(query, {\n    idField: idField\n  });\n  return useObservable(observableId, observable$, options);\n}\n/**\r\n * Calls a callable function.\r\n *\r\n * @param functionName - The name of the function to call\r\n * @param options\r\n */\n\n\nfunction useCallableFunctionResponse(functionName, options) {\n  var functions = useFunctions();\n  var observableId = \"functions:callableResponse:\" + functionName + \":\" + JSON.stringify(options == null ? void 0 : options.data) + \":\" + JSON.stringify(options == null ? void 0 : options.httpsCallableOptions);\n  var obsFactory = httpsCallable(functions, functionName, options == null ? void 0 : options.httpsCallableOptions);\n  var observable$ = obsFactory(options == null ? void 0 : options.data);\n  return useObservable(observableId, observable$, options);\n}\n\nfunction SuspenseWithPerf(_ref) {\n  var _performance;\n\n  var children = _ref.children,\n      traceId = _ref.traceId,\n      fallback = _ref.fallback; // TODO: Should this import firebase/performance?\n\n  var entries = ((_performance = performance) == null ? void 0 : _performance.getEntriesByName == null ? void 0 : _performance.getEntriesByName(traceId, 'measure')) || [];\n  var startMarkName = \"_\" + traceId + \"Start[\" + entries.length + \"]\";\n  var endMarkName = \"_\" + traceId + \"End[\" + entries.length + \"]\";\n\n  var Fallback = function Fallback() {\n    useLayoutEffect(function () {\n      var _performance2;\n\n      (_performance2 = performance) == null ? void 0 : _performance2.mark == null ? void 0 : _performance2.mark(startMarkName);\n      return function () {\n        var _performance3, _performance4;\n\n        (_performance3 = performance) == null ? void 0 : _performance3.mark == null ? void 0 : _performance3.mark(endMarkName);\n        (_performance4 = performance) == null ? void 0 : _performance4.measure == null ? void 0 : _performance4.measure(traceId, startMarkName, endMarkName);\n      };\n    }, []);\n    return createElement(Fragment, null, fallback);\n  };\n\n  return createElement(Suspense, {\n    fallback: createElement(Fallback, null)\n  }, children);\n}\n/**\r\n * Helper function to construct type safe functions. Since Remote Config has\r\n * methods that return different types for values, we need to be extra safe\r\n * to make sure we are not returning improper types by accident.\r\n * @param key\r\n * @param getter\r\n * @param remoteConfig\r\n */\n\n\nfunction useRemoteConfigValue_INTERNAL(key, getter) {\n  var remoteConfig = useRemoteConfig();\n  var appName = remoteConfig.app.name;\n  var $value = getter(remoteConfig, key);\n  var observableId = \"remoteConfig:\" + key + \":\" + getter.name + \":\" + appName;\n  return useObservable(observableId, $value);\n}\n/**\r\n * Accepts a key and optionally a Remote Config instance. Returns a\r\n * Remote Config Value.\r\n *\r\n * @param key The parameter key in Remote Config\r\n */\n\n\nfunction useRemoteConfigValue(key) {\n  return useRemoteConfigValue_INTERNAL(key, getValue);\n}\n/**\r\n * Convience method similar to useRemoteConfigValue. Returns a `string` from a Remote Config parameter.\r\n * @param key The parameter key in Remote Config\r\n */\n\n\nfunction useRemoteConfigString(key) {\n  return useRemoteConfigValue_INTERNAL(key, getString);\n}\n/**\r\n * Convience method similar to useRemoteConfigValue. Returns a `number` from a Remote Config parameter.\r\n * @param key The parameter key in Remote Config\r\n */\n\n\nfunction useRemoteConfigNumber(key) {\n  return useRemoteConfigValue_INTERNAL(key, getNumber);\n}\n/**\r\n * Convience method similar to useRemoteConfigValue. Returns a `boolean` from a Remote Config parameter.\r\n * @param key The parameter key in Remote Config\r\n */\n\n\nfunction useRemoteConfigBoolean(key) {\n  return useRemoteConfigValue_INTERNAL(key, getBoolean);\n}\n/**\r\n * Convience method similar to useRemoteConfigValue. Returns allRemote Config parameters.\r\n * @param key The parameter key in Remote Config\r\n */\n\n\nfunction useRemoteConfigAll(key) {\n  return useRemoteConfigValue_INTERNAL(key, getAll);\n}\n\nvar _excluded = [\"storage\", \"storagePath\", \"suspense\", \"placeHolder\"];\n/**\r\n * Subscribe to the progress of a storage task\r\n *\r\n * @param task - the task you want to listen to\r\n * @param ref - reference to the blob the task is acting on\r\n * @param options\r\n */\n\nfunction useStorageTask(task, ref, options) {\n  var observableId = \"storage:task:\" + ref.toString();\n  var observable$ = fromTask(task);\n  return useObservable(observableId, observable$, options);\n}\n/**\r\n * Subscribe to a storage ref's download URL\r\n *\r\n * @param ref - reference to the blob you want to download\r\n * @param options\r\n */\n\n\nfunction useStorageDownloadURL(ref, options) {\n  var observableId = \"storage:downloadUrl:\" + ref.toString();\n  var observable$ = getDownloadURL(ref);\n  return useObservable(observableId, observable$, options);\n}\n\nfunction StorageFromContext(props) {\n  var storage = useStorage();\n  props = _extends({}, props, {\n    storage: storage\n  });\n  return createElement(INTERNALStorageImage, _extends({}, props));\n}\n\nfunction INTERNALStorageImage(props) {\n  var storage = props.storage,\n      storagePath = props.storagePath,\n      suspense = props.suspense,\n      placeHolder = props.placeHolder,\n      imgProps = _objectWithoutPropertiesLoose(props, _excluded);\n\n  var reactfireOptions = {\n    suspense: useSuspenseEnabledFromConfigAndContext(suspense)\n  };\n\n  if (!storage) {\n    throw new Error('Storage was not passed to component INTERNALStorageImage. This should not be possible');\n  }\n\n  var _useStorageDownloadUR = useStorageDownloadURL(ref(storage, storagePath), reactfireOptions),\n      status = _useStorageDownloadUR.status,\n      imgSrc = _useStorageDownloadUR.data;\n\n  if (status === 'success') {\n    if (!(imgProps.alt || imgProps.alt === '')) {\n      console.warn(\"No alt prop provided for StorageImage with storagePath \\\"\" + storagePath + \"\\\"\", 'img elements must have an alt prop, either with meaningful text, or an empty string for decorative images');\n    }\n\n    return createElement(\"img\", _extends({\n      src: imgSrc,\n      alt: imgProps.alt\n    }, imgProps));\n  } else {\n    return placeHolder != null ? placeHolder : createElement(Fragment, null, \"''\");\n  }\n}\n\nfunction StorageImage(props) {\n  var storage = props.storage;\n\n  if (storage) {\n    return createElement(INTERNALStorageImage, _extends({}, props));\n  } else {\n    return createElement(StorageFromContext, _extends({}, props));\n  }\n}\n\nvar AppCheckSdkContext = /*#__PURE__*/createContext(undefined);\nvar AuthSdkContext = /*#__PURE__*/createContext(undefined);\nvar AnalyticsSdkContext = /*#__PURE__*/createContext(undefined);\nvar DatabaseSdkContext = /*#__PURE__*/createContext(undefined);\nvar FirestoreSdkContext = /*#__PURE__*/createContext(undefined);\nvar FunctionsSdkContext = /*#__PURE__*/createContext(undefined);\nvar StorageSdkContext = /*#__PURE__*/createContext(undefined);\nvar PerformanceSdkContext = /*#__PURE__*/createContext(undefined);\nvar RemoteConfigSdkContext = /*#__PURE__*/createContext(undefined);\n\nfunction getSdkProvider(SdkContext) {\n  return function SdkProvider(props) {\n    var _props$sdk, _props$sdk$app;\n\n    if (!props.sdk) throw new Error('no sdk provided');\n    var contextualAppName = useFirebaseApp().name;\n    var sdkAppName = props == null ? void 0 : (_props$sdk = props.sdk) == null ? void 0 : (_props$sdk$app = _props$sdk.app) == null ? void 0 : _props$sdk$app.name;\n    if (sdkAppName !== contextualAppName) throw new Error('sdk was initialized with a different firebase app');\n    return createElement(SdkContext.Provider, _extends({\n      value: props.sdk\n    }, props));\n  };\n}\n\nfunction useSdk(SdkContext) {\n  var sdk = useContext(SdkContext);\n\n  if (!sdk) {\n    throw new Error('SDK not found. useSdk must be called from within a provider');\n  }\n\n  return sdk;\n}\n\nfunction useInitSdk(sdkName, SdkContext, sdkInitializer, options) {\n  var firebaseApp = useFirebaseApp(); // Some initialization functions (like Firestore's `enableIndexedDbPersistence`)\n  // can only be called before anything else. So if an sdk is already available in context,\n  // it isn't safe to call initialization functions again.\n\n  if (useContext(SdkContext)) {\n    throw new Error(\"Cannot initialize SDK \" + sdkName + \" because it already exists in Context\");\n  }\n\n  var initializeSdk = useMemo(function () {\n    return sdkInitializer(firebaseApp);\n  }, [firebaseApp]);\n  return useObservable(\"firebase-sdk:\" + sdkName + \":\" + firebaseApp.name, from(initializeSdk), options);\n}\n\nvar AppCheckProvider = /*#__PURE__*/getSdkProvider(AppCheckSdkContext);\nvar AuthProvider = /*#__PURE__*/getSdkProvider(AuthSdkContext);\nvar AnalyticsProvider = /*#__PURE__*/getSdkProvider(AnalyticsSdkContext);\nvar DatabaseProvider = /*#__PURE__*/getSdkProvider(DatabaseSdkContext);\nvar FirestoreProvider = /*#__PURE__*/getSdkProvider(FirestoreSdkContext);\nvar FunctionsProvider = /*#__PURE__*/getSdkProvider(FunctionsSdkContext);\nvar PerformanceProvider = /*#__PURE__*/getSdkProvider(PerformanceSdkContext);\nvar StorageProvider = /*#__PURE__*/getSdkProvider(StorageSdkContext);\nvar RemoteConfigProvider = /*#__PURE__*/getSdkProvider(RemoteConfigSdkContext);\n\nvar useAppCheck = function useAppCheck() {\n  return useSdk(AppCheckSdkContext);\n};\n\nvar useAuth = function useAuth() {\n  return useSdk(AuthSdkContext);\n};\n\nvar useAnalytics = function useAnalytics() {\n  return useSdk(AnalyticsSdkContext);\n};\n\nvar useDatabase = function useDatabase() {\n  return useSdk(DatabaseSdkContext);\n};\n\nvar useFirestore = function useFirestore() {\n  return useSdk(FirestoreSdkContext);\n};\n\nvar useFunctions = function useFunctions() {\n  return useSdk(FunctionsSdkContext);\n};\n\nvar usePerformance = function usePerformance() {\n  return useSdk(PerformanceSdkContext);\n};\n\nvar useStorage = function useStorage() {\n  return useSdk(StorageSdkContext);\n};\n\nvar useRemoteConfig = function useRemoteConfig() {\n  return useSdk(RemoteConfigSdkContext);\n};\n\nvar useInitAppCheck = function useInitAppCheck(initializer, options) {\n  return useInitSdk('appcheck', AppCheckSdkContext, initializer, options);\n};\n\nvar useInitAuth = function useInitAuth(initializer, options) {\n  return useInitSdk('auth', AuthSdkContext, initializer, options);\n};\n\nvar useInitAnalytics = function useInitAnalytics(initializer, options) {\n  return useInitSdk('analytics', AnalyticsSdkContext, initializer, options);\n};\n\nvar useInitDatabase = function useInitDatabase(initializer, options) {\n  return useInitSdk('database', DatabaseSdkContext, initializer, options);\n};\n\nvar useInitFirestore = function useInitFirestore(initializer, options) {\n  return useInitSdk('firestore', FirestoreSdkContext, initializer, options);\n};\n\nvar useInitFunctions = function useInitFunctions(initializer, options) {\n  return useInitSdk('functions', FunctionsSdkContext, initializer, options);\n};\n\nvar useInitPerformance = function useInitPerformance(initializer, options) {\n  return useInitSdk('performance', PerformanceSdkContext, initializer, options);\n};\n\nvar useInitRemoteConfig = function useInitRemoteConfig(initializer, options) {\n  return useInitSdk('remoteconfig', RemoteConfigSdkContext, initializer, options);\n};\n\nvar useInitStorage = function useInitStorage(initializer, options) {\n  return useInitSdk('storage', StorageSdkContext, initializer, options);\n};\n\nvar ReactFireError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(ReactFireError, _Error);\n\n  function ReactFireError(code, message, customData) {\n    var _this;\n\n    _this = _Error.call(this, message) || this;\n    _this.code = void 0;\n    _this.customData = void 0;\n    _this.name = 'ReactFireError';\n    _this.code = code;\n    _this.customData = customData; // Fix For ES5\n    // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n\n    Object.setPrototypeOf(_assertThisInitialized(_this), ReactFireError.prototype);\n    return _this;\n  }\n\n  return ReactFireError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nfunction checkOptions(options, field) {\n  // make sure the field passed in is a valid key of ReactFire Options\n  if (field === 'idField' || field === 'initialData' || field === 'suspense') {\n    return options ? options[field] : undefined;\n  }\n\n  throw new Error(\"Field \\\"\" + field + \"\\\" is not a valid key in ReactFireOptions\");\n}\n\nfunction checkinitialData(options) {\n  return checkOptions(options, 'initialData');\n}\n\nfunction checkIdField(options) {\n  return checkOptions(options, 'idField');\n}\n\nexport { AnalyticsProvider, AppCheckProvider, AuthCheck, AuthProvider, ClaimsCheck, DatabaseProvider, FirebaseAppProvider, FirestoreProvider, FunctionsProvider, PerformanceProvider, ReactFireError, RemoteConfigProvider, StorageImage, StorageProvider, SuspenseWithPerf, checkIdField, checkOptions, checkinitialData, preloadFirestoreDoc, preloadObservable, preloadUser, useAnalytics, useAppCheck, useAuth, useCallableFunctionResponse, useDatabase, useDatabaseList, useDatabaseListData, useDatabaseObject, useDatabaseObjectData, useFirebaseApp, useFirestore, useFirestoreCollection, useFirestoreCollectionData, useFirestoreDoc, useFirestoreDocData, useFirestoreDocDataOnce, useFirestoreDocOnce, useFunctions, useIdTokenResult, useInitAnalytics, useInitAppCheck, useInitAuth, useInitDatabase, useInitFirestore, useInitFunctions, useInitPerformance, useInitRemoteConfig, useInitStorage, useIsSuspenseEnabled, useObservable, usePerformance, useRemoteConfig, useRemoteConfigAll, useRemoteConfigBoolean, useRemoteConfigNumber, useRemoteConfigString, useRemoteConfigValue, useSigninCheck, useStorage, useStorageDownloadURL, useStorageTask, useSuspenseEnabledFromConfigAndContext, useUser, version };","map":{"version":3,"sources":["../node_modules/regenerator-runtime/runtime.js","../src/firebaseApp.tsx","../src/auth.tsx","../src/database.tsx","../src/SuspenseSubject.ts","../src/useObservable.ts","../src/firestore.tsx","../src/functions.tsx","../src/performance.tsx","../src/remote-config.tsx","../src/storage.tsx","../src/sdk.tsx","../src/index.ts"],"names":["undefined","DEFAULT_APP_NAME","FirebaseAppContext","React","SuspenseEnabledContext","version","shallowEq","a","Object","b","FirebaseAppProvider","props","firebaseConfig","appName","suspense","firebaseApp","existingApp","app","reactVersion","registerVersion","initializeApp","value","useIsSuspenseEnabled","useSuspenseEnabledFromConfigAndContext","suspenseFromConfig","suspenseFromContext","useFirebaseApp","auth","authResolver","user$","preloadObservable","user","useUser","options","useAuth","observableId","observable$","currentUser","useObservable","initialData","useIdTokenResult","forceRefresh","from","useSigninCheck","JSON","observable","switchMap","result","signedIn","hasRequiredClaims","errors","of","map","validator","getClaimsObjectValidator","idTokenResult","requiredClaims","userClaims","ClaimsCheck","fallback","children","data","claims","missingClaims","suspenseMode","console","expected","actual","AuthCheck","cachedQueries","globalThis","index","cachedQuery","useDatabaseObject","ref","object","useDatabaseObjectData","idField","checkIdField","objectVal","keyField","useDatabaseList","hash","getUniqueIdForDatabaseQuery","list","useDatabaseListData","listVal","SuspenseSubject","_value","_hasValue","_timeoutHandler","_firstEmission","_error","_innerObservable","_warmupSubscription","_innerSubscriber","_resolveFirstEmission","tap","next","error","catchError","empty","shareReplay","setTimeout","Error","_next","_reset","_subscribe","clearTimeout","DEFAULT_TIMEOUT","preloadedObservables","source","id","newState","hasEmitted","state","firstValuePromise","firstEmission","config","hasInitialData","hasData","suspenseEnabled","initialState","status","isComplete","dispatch","reducerFactory","subscription","complete","queryEqual","refProvider","doc","getDocObservableId","useFirestoreDoc","useFirestoreDocOnce","first","useFirestoreDocData","docData","useFirestoreDocDataOnce","useFirestoreCollection","query","getUniqueIdForFirestoreQuery","fromRef","useFirestoreCollectionData","collectionData","useCallableFunctionResponse","functionName","functions","useFunctions","obsFactory","rxHttpsCallable","SuspenseWithPerf","traceId","entries","startMarkName","endMarkName","Fallback","remoteConfig","useRemoteConfig","$value","getter","useRemoteConfigValue","key","useRemoteConfigValue_INTERNAL","useRemoteConfigString","useRemoteConfigNumber","useRemoteConfigBoolean","useRemoteConfigAll","useStorageTask","task","fromTask","useStorageDownloadURL","getDownloadURL","storage","useStorage","storagePath","placeHolder","imgProps","reactfireOptions","imgSrc","src","alt","StorageImage","AppCheckSdkContext","AuthSdkContext","AnalyticsSdkContext","DatabaseSdkContext","FirestoreSdkContext","FunctionsSdkContext","StorageSdkContext","PerformanceSdkContext","RemoteConfigSdkContext","contextualAppName","sdkAppName","SdkContext","sdk","initializeSdk","sdkInitializer","AppCheckProvider","getSdkProvider","AuthProvider","AnalyticsProvider","DatabaseProvider","FirestoreProvider","FunctionsProvider","PerformanceProvider","StorageProvider","RemoteConfigProvider","useAppCheck","useSdk","useAnalytics","useDatabase","useFirestore","usePerformance","useInitAppCheck","useInitSdk","useInitAuth","useInitAnalytics","useInitDatabase","useInitFirestore","useInitFunctions","useInitPerformance","useInitRemoteConfig","useInitStorage","ReactFireError","name","checkOptions","field","checkinitialData"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import * as React from 'react';\nimport { getApps, initializeApp, registerVersion } from 'firebase/app';\n\nimport type { FirebaseApp, FirebaseOptions } from 'firebase/app';\n\n// INVESTIGATE I don't like magic strings, can we have export this in js-sdk?\nconst DEFAULT_APP_NAME = '[DEFAULT]';\n\nconst FirebaseAppContext = React.createContext<FirebaseApp | undefined>(undefined);\nconst SuspenseEnabledContext = React.createContext<boolean>(false);\n\ninterface FirebaseAppProviderProps {\n  firebaseApp?: FirebaseApp;\n  firebaseConfig?: FirebaseOptions;\n  appName?: string;\n  suspense?: boolean;\n}\n\n// @ts-expect-error: \"__REACTFIRE_VERSION__\" is replaced with actual ReactFire version (see babel.config.js)\nexport const version = __REACTFIRE_VERSION__;\n\nconst shallowEq = (a: { [key: string]: any }, b: { [key: string]: any }) => a === b || [...Object.keys(a), ...Object.keys(b)].every((key) => a[key] === b[key]);\n\nexport function FirebaseAppProvider(props: React.PropsWithChildren<FirebaseAppProviderProps>) {\n  const { firebaseConfig, appName, suspense } = props;\n\n  const firebaseApp: FirebaseApp = React.useMemo(() => {\n    if (props.firebaseApp) {\n      return props.firebaseApp;\n    }\n\n    const existingApp = getApps().find((app) => app.name === (appName || DEFAULT_APP_NAME));\n    if (existingApp) {\n      if (firebaseConfig && shallowEq(existingApp.options, firebaseConfig)) {\n        return existingApp;\n      } else {\n        throw new Error(\n          `Does not match the options already provided to the ${appName || 'default'} firebase app instance, give this new instance a different appName.`\n        );\n      }\n    } else {\n      if (!firebaseConfig) {\n        throw new Error('No firebaseConfig provided');\n      }\n\n      const reactVersion = React.version || 'unknown';\n      registerVersion('react', reactVersion);\n      registerVersion('reactfire', version);\n      return initializeApp(firebaseConfig, appName);\n    }\n  }, [props.firebaseApp, firebaseConfig, appName]);\n\n  return (\n    <FirebaseAppContext.Provider value={firebaseApp}>\n      <SuspenseEnabledContext.Provider value={suspense ?? false} {...props} />\n    </FirebaseAppContext.Provider>\n  );\n}\n\nexport function useIsSuspenseEnabled(): boolean {\n  const suspense = React.useContext(SuspenseEnabledContext);\n\n  // default to false if not available in context\n  return suspense ?? false;\n}\n\nexport function useSuspenseEnabledFromConfigAndContext(suspenseFromConfig?: boolean): boolean {\n  let suspenseFromContext = React.useContext(SuspenseEnabledContext);\n\n  // prioritize config over context\n  if (suspenseFromConfig !== undefined) {\n    return suspenseFromConfig;\n  }\n\n  return suspenseFromContext;\n}\n\nexport function useFirebaseApp() {\n  const firebaseApp = React.useContext(FirebaseAppContext);\n  if (!firebaseApp) {\n    throw new Error('Cannot call useFirebaseApp unless your component is within a FirebaseAppProvider');\n  }\n\n  return firebaseApp;\n}\n","import * as React from 'react';\nimport { user } from 'rxfire/auth';\nimport { preloadObservable, ReactFireOptions, useAuth, useObservable, ObservableStatus, ReactFireError } from './';\nimport { from, of } from 'rxjs';\nimport { map, switchMap } from 'rxjs/operators';\nimport { useSuspenseEnabledFromConfigAndContext } from './firebaseApp';\n\nimport type { Auth, User, IdTokenResult } from 'firebase/auth';\ntype Claims = IdTokenResult['claims'];\n\nexport async function preloadUser(authResolver: () => Promise<Auth>) {\n  const auth = await authResolver();\n  const user$ = preloadObservable(user(auth), `auth:user:${auth.name}`);\n  return user$.toPromise();\n}\n\n/**\n * Subscribe to Firebase auth state changes, including token refresh\n *\n * @param options\n */\nexport function useUser<T = unknown>(options?: ReactFireOptions<T>): ObservableStatus<User | null> {\n  const auth = useAuth();\n\n  const observableId = `auth:user:${auth.name}`;\n  const observable$ = user(auth);\n\n  let currentUser = auth.currentUser;\n\n  // Only use options.initialData if auth.currentUser is unavailable\n  if (!currentUser && (options?.initialData ?? options?.startWithValue)) {\n    currentUser = options.initialData ?? options.startWithValue;\n  }\n\n  return useObservable(observableId, observable$, { ...options, initialData: currentUser });\n}\n\nexport function useIdTokenResult(user: User, forceRefresh: boolean = false, options?: ReactFireOptions<IdTokenResult>): ObservableStatus<IdTokenResult> {\n  if (!user) {\n    throw new Error('you must provide a user');\n  }\n\n  const observableId = `auth:idTokenResult:${user.uid}:forceRefresh=${forceRefresh}`;\n  const observable$ = from(user.getIdTokenResult(forceRefresh));\n\n  return useObservable(observableId, observable$, options);\n}\n\nexport interface AuthCheckProps {\n  fallback: React.ReactNode;\n  children: React.ReactNode;\n  requiredClaims?: Object;\n}\n\nexport interface ClaimsCheckProps {\n  user: User;\n  fallback: React.ReactNode;\n  children: React.ReactNode;\n  requiredClaims: { [key: string]: any };\n}\n\nexport interface ClaimCheckErrors {\n  [key: string]: any[];\n}\n\nexport type SigninCheckResult =\n  | {\n      signedIn: false;\n      hasRequiredClaims: false;\n      errors: {};\n      user: null;\n    }\n  | {\n      signedIn: true;\n      hasRequiredClaims: boolean;\n      errors: ClaimCheckErrors;\n      user: User;\n    };\n\nexport interface SignInCheckOptionsBasic extends ReactFireOptions<SigninCheckResult> {\n  forceRefresh?: boolean;\n}\n\nexport interface SignInCheckOptionsClaimsObject extends SignInCheckOptionsBasic {\n  requiredClaims: Claims;\n}\n\nexport interface ClaimsValidator {\n  (claims: Claims): {\n    hasRequiredClaims: boolean;\n    errors: ClaimCheckErrors | {};\n  };\n}\n\nexport interface SignInCheckOptionsClaimsValidator extends SignInCheckOptionsBasic {\n  validateCustomClaims: ClaimsValidator;\n}\n\n/**\n * Subscribe to the signed-in status of a user.\n *\n * ```ts\n * const { status, data:signInCheckResult } = useSigninCheck();\n *\n * if (status === 'loading') {\n *   return <LoadingSpinner />}\n *\n *\n * if (signInCheckResult.signedIn === true) {\n *   return <ProfilePage user={signInCheckResult.user}/>\n * } else {\n *   return <SignInForm />\n * }\n * ```\n *\n * Optionally check [custom claims](https://firebase.google.com/docs/auth/admin/custom-claims) of a user as well.\n *\n * ```ts\n * // pass in an object describing the custom claims a user must have\n * const {status, data: signInCheckResult} = useSignInCheck({requiredClaims: {admin: true}});\n *\n * // pass in a custom claims validator function\n * const {status, data: signInCheckResult} = useSignInCheck({validateCustomClaims: (userClaims) => {\n *   // custom validation logic...\n * }});\n *\n * // You can optionally force-refresh the token\n * const {status, data: signInCheckResult} = useSignInCheck({forceRefresh: true, requiredClaims: {admin: true}});\n * ```\n */\nexport function useSigninCheck(\n  options?: SignInCheckOptionsBasic | SignInCheckOptionsClaimsObject | SignInCheckOptionsClaimsValidator\n): ObservableStatus<SigninCheckResult> {\n  // If both `requiredClaims` and `validateCustomClaims` are provided, we won't know which one to use\n  if (options?.hasOwnProperty('requiredClaims') && options?.hasOwnProperty('validateCustomClaims')) {\n    throw new Error('Cannot have both \"requiredClaims\" and \"validateCustomClaims\". Use one or the other.');\n  }\n\n  const auth = useAuth();\n\n  // ObservableId should change for different options configurations to ensure no cache collisions\n  let observableId = `auth:signInCheck:${auth.name}::forceRefresh:${!!options?.forceRefresh}`;\n  if (options?.forceRefresh) {\n    observableId = `${observableId}:forceRefresh:${options.forceRefresh}`;\n  }\n  if (options?.hasOwnProperty('requiredClaims')) {\n    observableId = `${observableId}:requiredClaims:${JSON.stringify((options as SignInCheckOptionsClaimsObject).requiredClaims)}`;\n  } else if (options?.hasOwnProperty('validateCustomClaims')) {\n    // TODO(jamesdaniels): Check if stringifying this function breaks in IE11\n    observableId = `${observableId}:validateCustomClaims:${JSON.stringify((options as SignInCheckOptionsClaimsValidator).validateCustomClaims)}`;\n  }\n\n  const observable = user(auth).pipe(\n    switchMap((user) => {\n      if (!user) {\n        const result: SigninCheckResult = { signedIn: false, hasRequiredClaims: false, errors: {}, user: null };\n        return of(result);\n      } else if (options && (options.hasOwnProperty('requiredClaims') || options.hasOwnProperty('validateCustomClaims'))) {\n        return from(user.getIdTokenResult(options?.forceRefresh ?? false)).pipe(\n          map((idTokenResult) => {\n            let validator: ClaimsValidator;\n\n            if (options.hasOwnProperty('requiredClaims')) {\n              validator = getClaimsObjectValidator((options as SignInCheckOptionsClaimsObject).requiredClaims);\n            } else {\n              validator = (options as SignInCheckOptionsClaimsValidator).validateCustomClaims;\n            }\n\n            const { hasRequiredClaims, errors } = validator(idTokenResult.claims);\n\n            const result: SigninCheckResult = { signedIn: true, hasRequiredClaims, errors, user: user };\n            return result;\n          })\n        );\n      } else {\n        // If no claims are provided to be checked, `hasRequiredClaims` is true\n        const result: SigninCheckResult = { signedIn: true, hasRequiredClaims: true, errors: {}, user: user };\n        return of(result);\n      }\n    })\n  );\n\n  return useObservable(observableId, observable);\n}\n\nfunction getClaimsObjectValidator(requiredClaims: Claims): ClaimsValidator {\n  return function claimsObjectValidator(userClaims) {\n    const errors: { [key: string]: ReactFireError[] } = {};\n\n    Object.keys(requiredClaims).forEach((claim) => {\n      if (requiredClaims[claim] !== userClaims[claim]) {\n        errors[claim] = [new ReactFireError('auth/missing-claim', `Expected \"${requiredClaims[claim]}\", but user has \"${userClaims[claim]}\" instead`)];\n      }\n    });\n\n    return {\n      hasRequiredClaims: Object.keys(errors).length === 0,\n      errors,\n    };\n  };\n}\n\n/**\n * @deprecated Use `useSignInCheck` instead\n *\n * Conditionally render children based on [custom claims](https://firebase.google.com/docs/auth/admin/custom-claims).\n *\n * Meant for Concurrent mode only (`<FirebaseAppProvider suspense=true />`). [More detail](https://github.com/FirebaseExtended/reactfire/issues/325#issuecomment-827654376).\n */\nexport function ClaimsCheck({ user, fallback, children, requiredClaims }: ClaimsCheckProps) {\n  const { data } = useIdTokenResult(user, false);\n  const { claims } = data;\n  const missingClaims: { [key: string]: { expected: string; actual: string | undefined } } = {};\n\n  const suspenseMode = useSuspenseEnabledFromConfigAndContext();\n  if (!suspenseMode) {\n    console.warn(\n      'ClaimsCheck is deprecated and only works when ReactFire is in experimental Suspense Mode. Use useSigninCheck or set suspense={true} in FirebaseAppProvider if you want to use this component.'\n    );\n  }\n\n  if (requiredClaims) {\n    Object.keys(requiredClaims).forEach((claim) => {\n      if (requiredClaims[claim] !== claims[claim]) {\n        missingClaims[claim] = {\n          expected: requiredClaims[claim],\n          actual: claims[claim]?.toString(),\n        };\n      }\n    });\n  }\n\n  if (Object.keys(missingClaims).length === 0) {\n    return <>{children}</>;\n  } else {\n    return <>{fallback}</>;\n  }\n}\n\n/**\n * @deprecated Use `useSignInCheck` instead\n *\n * Conditionally render children based on signed-in status and [custom claims](https://firebase.google.com/docs/auth/admin/custom-claims).\n *\n * Meant for Concurrent mode only (`<FirebaseAppProvider suspense=true />`). [More detail](https://github.com/FirebaseExtended/reactfire/issues/325#issuecomment-827654376).\n */\nexport function AuthCheck({ fallback, children, requiredClaims }: AuthCheckProps): JSX.Element {\n  const { data: user } = useUser<User>();\n\n  const suspenseMode = useSuspenseEnabledFromConfigAndContext();\n  if (!suspenseMode) {\n    console.warn(\n      'AuthCheck is deprecated and only works when ReactFire is in experimental Suspense Mode. Use useSigninCheck or set suspense={true} in FirebaseAppProvider if you want to use this component.'\n    );\n  }\n\n  if (user) {\n    return requiredClaims ? (\n      <ClaimsCheck user={user} fallback={fallback} requiredClaims={requiredClaims}>\n        {children}\n      </ClaimsCheck>\n    ) : (\n      <>{children}</>\n    );\n  } else {\n    return <>{fallback}</>;\n  }\n}\n","import { list, object, QueryChange, listVal, objectVal } from 'rxfire/database';\nimport { ReactFireOptions, useObservable, checkIdField, ObservableStatus, ReactFireGlobals } from './';\n\nimport type { Query as DatabaseQuery, DatabaseReference } from 'firebase/database';\n\n// Since we're side-effect free, we need to ensure our observableId cache is global\nconst cachedQueries: Array<DatabaseQuery> = (globalThis as any as ReactFireGlobals)._reactFireDatabaseCachedQueries || [];\n\nif (!(globalThis as any as ReactFireGlobals)._reactFireDatabaseCachedQueries) {\n  (globalThis as any as ReactFireGlobals)._reactFireDatabaseCachedQueries = cachedQueries;\n}\n\nfunction getUniqueIdForDatabaseQuery(query: DatabaseQuery) {\n  const index = cachedQueries.findIndex((cachedQuery) => cachedQuery.isEqual(query));\n  if (index > -1) {\n    return index;\n  }\n  return cachedQueries.push(query) - 1;\n}\n\n/**\n * Subscribe to a Realtime Database object\n *\n * @param ref - Reference to the DB object you want to listen to\n * @param options\n */\nexport function useDatabaseObject<T = unknown>(ref: DatabaseReference, options?: ReactFireOptions<T>): ObservableStatus<QueryChange | T> {\n  const observableId = `database:object:${ref.toString()}`;\n  const observable$ = object(ref);\n\n  return useObservable(observableId, observable$, options);\n}\n\nexport function useDatabaseObjectData<T>(ref: DatabaseReference, options?: ReactFireOptions<T>): ObservableStatus<T> {\n  const idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  const observableId = `database:objectVal:${ref.toString()}:idField=${idField}`;\n  const observable$ = objectVal<T>(ref, { keyField: idField });\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Subscribe to a Realtime Database list\n *\n * @param ref - Reference to the DB List you want to listen to\n * @param options\n */\nexport function useDatabaseList<T = { [key: string]: unknown }>(\n  ref: DatabaseReference | DatabaseQuery,\n  options?: ReactFireOptions<T[]>\n): ObservableStatus<QueryChange[] | T[]> {\n  const hash = `database:list:${getUniqueIdForDatabaseQuery(ref)}`;\n  const observable$ = list(ref);\n\n  return useObservable(hash, observable$, options);\n}\n\nexport function useDatabaseListData<T = { [key: string]: unknown }>(\n  ref: DatabaseReference | DatabaseQuery,\n  options?: ReactFireOptions<T[]>\n): ObservableStatus<T[] | null> {\n  const idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  const observableId = `database:listVal:${getUniqueIdForDatabaseQuery(ref)}:idField=${idField}`;\n  const observable$ = listVal<T>(ref, { keyField: idField });\n  return useObservable(observableId, observable$, options);\n}\n","import { empty, Observable, Subject, Subscriber, Subscription } from 'rxjs';\nimport { catchError, shareReplay, tap } from 'rxjs/operators';\n\nexport class SuspenseSubject<T> extends Subject<T> {\n  private _value: T | undefined;\n  private _hasValue = false;\n  private _timeoutHandler: NodeJS.Timeout;\n  private _firstEmission: Promise<void>;\n  private _error: any = undefined;\n  private _innerObservable: Observable<T>;\n  private _warmupSubscription: Subscription;\n\n  // @ts-expect-error: TODO: double check to see if this is an RXJS thing or if we should listen to TS\n  private _innerSubscriber: Subscription;\n  // @ts-expect-error: TODO: double check to see if this is an RXJS thing or if we should listen to TS\n  private _resolveFirstEmission: () => void;\n\n  constructor(innerObservable: Observable<T>, private _timeoutWindow: number) {\n    super();\n    this._firstEmission = new Promise<void>((resolve) => (this._resolveFirstEmission = resolve));\n    this._innerObservable = innerObservable.pipe(\n      tap({\n        next: (v) => {\n          this._next(v);\n        },\n        error: (e) => {\n          // save the error, so that we can raise on subscription or .value\n          // resolve the promise, so suspense tries again\n          this._error = e;\n          this._resolveFirstEmission();\n        },\n      }),\n      catchError(() => empty()),\n      shareReplay(1)\n    );\n    // warm up the observable\n    this._warmupSubscription = this._innerObservable.subscribe();\n\n    // set a timeout for resetting the cache, subscriptions will cancel the timeout\n    // and reschedule again on unsubscribe\n    this._timeoutHandler = setTimeout(this._reset.bind(this), this._timeoutWindow);\n  }\n\n  get hasValue(): boolean {\n    // hasValue returns true if there's an error too\n    // so that after we resolve the promise & useObservable is called again\n    // we won't throw again\n    return this._hasValue || !!this._error;\n  }\n\n  get value(): T {\n    // TODO figure out how to reset the cache here, if I _reset() here before throwing\n    // it doesn't seem to work.\n    // As it is now, this will burn the cache entry until the timeout fires.\n    if (this._error) {\n      throw this._error;\n    } else if (!this.hasValue) {\n      throw Error('Can only get value if SuspenseSubject has a value');\n    }\n    return this._value as T;\n  }\n\n  get firstEmission(): Promise<void> {\n    return this._firstEmission;\n  }\n\n  private _next(value: T) {\n    this._hasValue = true;\n    this._value = value;\n    this._resolveFirstEmission();\n  }\n\n  private _reset() {\n    // seems to be undefined in tests?\n    if (this._warmupSubscription) {\n      this._warmupSubscription.unsubscribe();\n    }\n    this._hasValue = false;\n    this._value = undefined;\n    this._error = undefined;\n    this._firstEmission = new Promise<void>((resolve) => (this._resolveFirstEmission = resolve));\n  }\n\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    if (this._timeoutHandler) {\n      clearTimeout(this._timeoutHandler);\n    }\n    this._innerSubscriber = this._innerObservable.subscribe(subscriber);\n    return this._innerSubscriber;\n  }\n\n  get ourError() {\n    return this._error;\n  }\n}\n","import * as React from 'react';\nimport { Observable } from 'rxjs';\nimport { SuspenseSubject } from './SuspenseSubject';\nimport { useSuspenseEnabledFromConfigAndContext } from './firebaseApp';\nimport { ReactFireGlobals, ReactFireOptions } from './';\n\nconst DEFAULT_TIMEOUT = 30_000;\n\n// Since we're side-effect free, we need to ensure our observable cache is global\nconst preloadedObservables: Map<string, SuspenseSubject<any>> = (globalThis as any as ReactFireGlobals)._reactFirePreloadedObservables || new Map();\n\nif (!(globalThis as any as ReactFireGlobals)._reactFirePreloadedObservables) {\n  (globalThis as any as ReactFireGlobals)._reactFirePreloadedObservables = preloadedObservables;\n}\n\n// Starts listening to an Observable.\n// Call this once you know you're going to render a\n// child that will consume the observable\nexport function preloadObservable<T>(source: Observable<T>, id: string) {\n  if (preloadedObservables.has(id)) {\n    return preloadedObservables.get(id) as SuspenseSubject<T>;\n  } else {\n    const observable = new SuspenseSubject(source, DEFAULT_TIMEOUT);\n    preloadedObservables.set(id, observable);\n    return observable;\n  }\n}\n\nexport interface ObservableStatus<T> {\n  /**\n   * The loading status.\n   *\n   * - `loading`: Waiting for the first value from an observable\n   * - `error`: Something went wrong. Check `ObservableStatus.error` for more details\n   * - `success`: The hook has emitted at least one value\n   *\n   * If `initialData` is passed in, this will skip `loading` and go straight to `success`.\n   */\n  status: 'loading' | 'error' | 'success';\n  /**\n   * Indicates whether the hook has emitted a value at some point\n   *\n   * If `initialData` is passed in, this will be `true`.\n   */\n  hasEmitted: boolean; // has received at least one value\n  /**\n   * If this is `true`, the hook will be emitting no further items.\n   */\n  isComplete: boolean;\n  /**\n   * The most recent value.\n   *\n   * If `initialData` is passed in, the first value of `data` will be the valuea provided in `initialData` **UNLESS** the underlying observable is ready, in which case it will skip `initialData`.\n   */\n  data: T;\n  /**\n   * Any error that may have occurred in the underlying observable\n   */\n  error: Error | undefined;\n  /**\n   * Promise that resolves after first emit from observable\n   */\n  firstValuePromise: Promise<void>;\n}\n\nfunction reducerFactory<T>(observable: SuspenseSubject<T>) {\n  return function reducer(state: ObservableStatus<T>, action: 'value' | 'error' | 'complete'): ObservableStatus<T> {\n    // always make sure these values are in sync with the observable\n    const newState = {\n      ...state,\n      hasEmitted: state.hasEmitted || observable.hasValue,\n      error: observable.ourError,\n      firstValuePromise: observable.firstEmission,\n    };\n    if (observable.hasValue) {\n      newState.data = observable.value;\n    }\n\n    switch (action) {\n      case 'value':\n        newState.status = 'success';\n        return newState;\n      case 'error':\n        newState.status = 'error';\n        return newState;\n      case 'complete':\n        newState.isComplete = true;\n        return newState;\n      default:\n        throw new Error(`invalid action \"${action}\"`);\n    }\n  };\n}\n\nexport function useObservable<T = unknown>(observableId: string, source: Observable<T>, config: ReactFireOptions = {}): ObservableStatus<T> {\n  // Register the observable with the cache\n  if (!observableId) {\n    throw new Error('cannot call useObservable without an observableId');\n  }\n  const observable = preloadObservable(source, observableId);\n\n  // Suspend if suspense is enabled and no initial data exists\n  const hasInitialData = config.hasOwnProperty('initialData') || config.hasOwnProperty('startWithValue');\n  const hasData = observable.hasValue || hasInitialData;\n  const suspenseEnabled = useSuspenseEnabledFromConfigAndContext(config.suspense);\n  if (suspenseEnabled === true && !hasData) {\n    throw observable.firstEmission;\n  }\n\n  const initialState: ObservableStatus<T> = {\n    status: hasData ? 'success' : 'loading',\n    hasEmitted: hasData,\n    isComplete: false,\n    data: observable.hasValue ? observable.value : config?.initialData ?? config?.startWithValue,\n    error: observable.ourError,\n    firstValuePromise: observable.firstEmission,\n  };\n  const [status, dispatch] = React.useReducer<React.Reducer<ObservableStatus<T>, 'value' | 'error' | 'complete'>>(reducerFactory<T>(observable), initialState);\n\n  React.useEffect(() => {\n    const subscription = observable.subscribe({\n      next: () => {\n        dispatch('value');\n      },\n      error: (e) => {\n        dispatch('error');\n        throw e;\n      },\n      complete: () => {\n        dispatch('complete');\n      },\n    });\n    return () => subscription.unsubscribe();\n  }, [observable]);\n\n  return status;\n}\n","import { collectionData, doc, docData, fromRef } from 'rxfire/firestore';\nimport { ReactFireOptions, useObservable, checkIdField, ReactFireGlobals } from './';\nimport { preloadObservable, ObservableStatus } from './useObservable';\nimport { first } from 'rxjs/operators';\n\nimport { Query as FirestoreQuery, QuerySnapshot, DocumentReference, queryEqual, DocumentData, DocumentSnapshot } from 'firebase/firestore';\n\n// Since we're side-effect free, we need to ensure our observableId cache is global\nconst cachedQueries: Array<FirestoreQuery> = (globalThis as any as ReactFireGlobals)._reactFireFirestoreQueryCache || [];\n\nif (!(globalThis as any as ReactFireGlobals)._reactFireFirestoreQueryCache) {\n  (globalThis as any as ReactFireGlobals)._reactFireFirestoreQueryCache = cachedQueries;\n}\n\nfunction getUniqueIdForFirestoreQuery(query: FirestoreQuery) {\n  const index = cachedQueries.findIndex((cachedQuery) => queryEqual(cachedQuery, query));\n  if (index > -1) {\n    return index;\n  }\n  return cachedQueries.push(query) - 1;\n}\n\n/**\n * Preload a subscription to a Firestore document reference.\n *\n * Use this to warm up `useFirestoreDoc` for a specific document\n */\nexport async function preloadFirestoreDoc(refProvider: () => Promise<DocumentReference>) {\n  const ref = await refProvider();\n  return preloadObservable(doc(ref), getDocObservableId(ref));\n}\n\nfunction getDocObservableId(ref: DocumentReference) {\n  return `firestore:doc:${ref.firestore.app.name}:${ref.path}`;\n}\n\n/**\n * Suscribe to Firestore Document changes\n *\n * You can preload data for this hook by calling `preloadFirestoreDoc`\n */\nexport function useFirestoreDoc<T = DocumentData>(ref: DocumentReference<T>, options?: ReactFireOptions<T>): ObservableStatus<DocumentSnapshot<T>> {\n  const observableId = getDocObservableId(ref);\n  const observable$ = doc(ref);\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Get a firestore document and don't subscribe to changes\n */\nexport function useFirestoreDocOnce<T = DocumentData>(ref: DocumentReference<T>, options?: ReactFireOptions<T>): ObservableStatus<DocumentSnapshot<T>> {\n  const observableId = `firestore:docOnce:${ref.firestore.app.name}:${ref.path}`;\n  const observable$ = doc(ref).pipe(first());\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Suscribe to Firestore Document changes and unwrap the document into a plain object\n */\nexport function useFirestoreDocData<T = unknown>(ref: DocumentReference<T>, options?: ReactFireOptions<T>): ObservableStatus<T> {\n  const idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n\n  const observableId = `firestore:docData:${ref.firestore.app.name}:${ref.path}:idField=${idField}`;\n  const observable = docData(ref, { idField });\n\n  return useObservable(observableId, observable, options);\n}\n\n/**\n * Get a Firestore document, unwrap the document into a plain object, and don't subscribe to changes\n */\nexport function useFirestoreDocDataOnce<T = unknown>(ref: DocumentReference<T>, options?: ReactFireOptions<T>): ObservableStatus<T> {\n  const idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n\n  const observableId = `firestore:docDataOnce:${ref.firestore.app.name}:${ref.path}:idField=${idField}`;\n  const observable$ = docData(ref, { idField }).pipe(first());\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Subscribe to a Firestore collection\n */\nexport function useFirestoreCollection<T = DocumentData>(query: FirestoreQuery<T>, options?: ReactFireOptions<T[]>): ObservableStatus<QuerySnapshot<T>> {\n  const observableId = `firestore:collection:${getUniqueIdForFirestoreQuery(query)}`;\n  const observable$ = fromRef(query);\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Subscribe to a Firestore collection and unwrap the snapshot into an array.\n */\nexport function useFirestoreCollectionData<T = DocumentData>(query: FirestoreQuery<T>, options?: ReactFireOptions<T[]>): ObservableStatus<T[]> {\n  const idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  const observableId = `firestore:collectionData:${getUniqueIdForFirestoreQuery(query)}:idField=${idField}`;\n  const observable$ = collectionData(query, { idField });\n\n  return useObservable(observableId, observable$, options);\n}\n","import { httpsCallable as rxHttpsCallable } from 'rxfire/functions';\nimport { ReactFireOptions, useObservable, ObservableStatus } from './';\nimport { useFunctions } from '.';\n\nimport type { HttpsCallableOptions } from 'firebase/functions';\n\n/**\n * Calls a callable function.\n *\n * @param functionName - The name of the function to call\n * @param options\n */\nexport function useCallableFunctionResponse<RequestData, ResponseData>(\n  functionName: string,\n  options?: ReactFireOptions<ResponseData> & {\n    httpsCallableOptions?: HttpsCallableOptions;\n    data?: RequestData;\n  }\n): ObservableStatus<ResponseData> {\n  const functions = useFunctions();\n  const observableId = `functions:callableResponse:${functionName}:${JSON.stringify(options?.data)}:${JSON.stringify(options?.httpsCallableOptions)}`;\n  const obsFactory = rxHttpsCallable<RequestData, ResponseData>(functions, functionName, options?.httpsCallableOptions);\n  const observable$ = obsFactory(options?.data);\n\n  return useObservable(observableId, observable$, options);\n}\n","import * as React from 'react';\n\nexport interface SuspensePerfProps {\n  children: React.ReactNode;\n  traceId: string;\n  fallback: React.ReactNode;\n}\n\nexport function SuspenseWithPerf({ children, traceId, fallback }: SuspensePerfProps): JSX.Element {\n  // TODO: Should this import firebase/performance?\n\n  const entries = performance?.getEntriesByName?.(traceId, 'measure') || [];\n  const startMarkName = `_${traceId}Start[${entries.length}]`;\n  const endMarkName = `_${traceId}End[${entries.length}]`;\n\n  const Fallback = () => {\n    React.useLayoutEffect(() => {\n      performance?.mark?.(startMarkName);\n\n      return () => {\n        performance?.mark?.(endMarkName);\n        performance?.measure?.(traceId, startMarkName, endMarkName);\n      };\n    }, []);\n\n    return <>{fallback}</>;\n  };\n\n  return <React.Suspense fallback={<Fallback />}>{children}</React.Suspense>;\n}\n","import { useRemoteConfig } from './';\nimport { useObservable, ObservableStatus } from './useObservable';\nimport { getValue, getString, getBoolean, getNumber, getAll, AllParameters } from 'rxfire/remote-config';\nimport { Observable } from 'rxjs';\n\nimport type { RemoteConfig, Value as RemoteConfigValue } from 'firebase/remote-config';\n\ntype Getter$<T> = (remoteConfig: RemoteConfig, key: string) => Observable<T>;\n\n/**\n * Helper function to construct type safe functions. Since Remote Config has\n * methods that return different types for values, we need to be extra safe\n * to make sure we are not returning improper types by accident.\n * @param key\n * @param getter\n * @param remoteConfig\n */\nfunction useRemoteConfigValue_INTERNAL<T>(key: string, getter: Getter$<T>): ObservableStatus<T> {\n  const remoteConfig = useRemoteConfig();\n\n  const appName = remoteConfig.app.name;\n  const $value = getter(remoteConfig, key);\n\n  const observableId = `remoteConfig:${key}:${getter.name}:${appName}`;\n  return useObservable<T>(observableId, $value);\n}\n\n/**\n * Accepts a key and optionally a Remote Config instance. Returns a\n * Remote Config Value.\n *\n * @param key The parameter key in Remote Config\n */\nexport function useRemoteConfigValue(key: string): ObservableStatus<RemoteConfigValue> {\n  return useRemoteConfigValue_INTERNAL<RemoteConfigValue>(key, getValue);\n}\n\n/**\n * Convience method similar to useRemoteConfigValue. Returns a `string` from a Remote Config parameter.\n * @param key The parameter key in Remote Config\n */\nexport function useRemoteConfigString(key: string): ObservableStatus<string> {\n  return useRemoteConfigValue_INTERNAL<string>(key, getString);\n}\n\n/**\n * Convience method similar to useRemoteConfigValue. Returns a `number` from a Remote Config parameter.\n * @param key The parameter key in Remote Config\n */\nexport function useRemoteConfigNumber(key: string): ObservableStatus<number> {\n  return useRemoteConfigValue_INTERNAL<number>(key, getNumber);\n}\n\n/**\n * Convience method similar to useRemoteConfigValue. Returns a `boolean` from a Remote Config parameter.\n * @param key The parameter key in Remote Config\n */\nexport function useRemoteConfigBoolean(key: string): ObservableStatus<boolean> {\n  return useRemoteConfigValue_INTERNAL<boolean>(key, getBoolean);\n}\n\n/**\n * Convience method similar to useRemoteConfigValue. Returns allRemote Config parameters.\n * @param key The parameter key in Remote Config\n */\nexport function useRemoteConfigAll(key: string): ObservableStatus<AllParameters> {\n  return useRemoteConfigValue_INTERNAL<AllParameters>(key, getAll);\n}\n","import * as React from 'react';\nimport { getDownloadURL, fromTask } from 'rxfire/storage';\nimport { ReactFireOptions, useObservable, ObservableStatus, useStorage } from './';\nimport { useSuspenseEnabledFromConfigAndContext } from './firebaseApp';\nimport { ref } from 'firebase/storage';\n\nimport type { UploadTask, UploadTaskSnapshot, StorageReference, FirebaseStorage } from 'firebase/storage';\n\n/**\n * Subscribe to the progress of a storage task\n *\n * @param task - the task you want to listen to\n * @param ref - reference to the blob the task is acting on\n * @param options\n */\nexport function useStorageTask<T = unknown>(task: UploadTask, ref: StorageReference, options?: ReactFireOptions<T>): ObservableStatus<UploadTaskSnapshot | T> {\n  const observableId = `storage:task:${ref.toString()}`;\n  const observable$ = fromTask(task);\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Subscribe to a storage ref's download URL\n *\n * @param ref - reference to the blob you want to download\n * @param options\n */\nexport function useStorageDownloadURL<T = string>(ref: StorageReference, options?: ReactFireOptions<T>): ObservableStatus<string | T> {\n  const observableId = `storage:downloadUrl:${ref.toString()}`;\n  const observable$ = getDownloadURL(ref);\n\n  return useObservable(observableId, observable$, options);\n}\n\ntype StorageImageProps = {\n  storagePath: string;\n  storage?: FirebaseStorage;\n  suspense?: boolean;\n  placeHolder?: JSX.Element;\n};\n\nfunction StorageFromContext(props: StorageImageProps & React.DetailedHTMLProps<React.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>) {\n  const storage = useStorage();\n\n  props = { ...props, storage };\n\n  return <INTERNALStorageImage {...props} />;\n}\n\nfunction INTERNALStorageImage(props: StorageImageProps & React.DetailedHTMLProps<React.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>): JSX.Element {\n  let { storage, storagePath, suspense, placeHolder, ...imgProps } = props;\n\n  const reactfireOptions: ReactFireOptions<string> = {\n    suspense: useSuspenseEnabledFromConfigAndContext(suspense),\n  };\n\n  if (!storage) {\n    throw new Error('Storage was not passed to component INTERNALStorageImage. This should not be possible');\n  }\n\n  const { status, data: imgSrc } = useStorageDownloadURL(ref(storage, storagePath), reactfireOptions);\n\n  if (status === 'success') {\n    if (!(imgProps.alt || imgProps.alt === '')) {\n      console.warn(\n        `No alt prop provided for StorageImage with storagePath \"${storagePath}\"`,\n        'img elements must have an alt prop, either with meaningful text, or an empty string for decorative images'\n      );\n    }\n\n    return <img src={imgSrc} alt={imgProps.alt} {...imgProps} />;\n  } else {\n    return placeHolder ?? <>''</>;\n  }\n}\n\nexport function StorageImage(props: StorageImageProps & React.DetailedHTMLProps<React.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>) {\n  let { storage } = props;\n\n  if (storage) {\n    return <INTERNALStorageImage {...props} />;\n  } else {\n    return <StorageFromContext {...props} />;\n  }\n}\n","import * as React from 'react';\n\nimport type { AppCheck } from 'firebase/app-check';\nimport type { Auth } from 'firebase/auth';\nimport type { Analytics } from 'firebase/analytics';\nimport type { Database } from 'firebase/database';\nimport type { Firestore } from 'firebase/firestore';\nimport type { Functions } from 'firebase/functions';\nimport type { FirebasePerformance } from 'firebase/performance';\nimport type { FirebaseStorage } from 'firebase/storage';\nimport type { RemoteConfig } from 'firebase/remote-config';\nimport { useFirebaseApp } from './firebaseApp';\nimport { FirebaseApp } from 'firebase/app';\nimport { ObservableStatus, useObservable } from './useObservable';\nimport { from } from 'rxjs';\nimport { ReactFireOptions } from '.';\n\nconst AppCheckSdkContext = React.createContext<AppCheck | undefined>(undefined);\nconst AuthSdkContext = React.createContext<Auth | undefined>(undefined);\nconst AnalyticsSdkContext = React.createContext<Analytics | undefined>(undefined);\nconst DatabaseSdkContext = React.createContext<Database | undefined>(undefined);\nconst FirestoreSdkContext = React.createContext<Firestore | undefined>(undefined);\nconst FunctionsSdkContext = React.createContext<Functions | undefined>(undefined);\nconst StorageSdkContext = React.createContext<FirebaseStorage | undefined>(undefined);\nconst PerformanceSdkContext = React.createContext<FirebasePerformance | undefined>(undefined);\nconst RemoteConfigSdkContext = React.createContext<RemoteConfig | undefined>(undefined);\n\ntype FirebaseSdks = Analytics | AppCheck | Auth | Database | Firestore | FirebasePerformance | FirebaseStorage | Functions | RemoteConfig;\n\nfunction getSdkProvider<Sdk extends FirebaseSdks>(SdkContext: React.Context<Sdk | undefined>) {\n  return function SdkProvider(props: React.PropsWithChildren<{ sdk: Sdk }>) {\n    if (!props.sdk) throw new Error('no sdk provided');\n\n    const contextualAppName = useFirebaseApp().name;\n    const sdkAppName = props?.sdk?.app?.name;\n    if (sdkAppName !== contextualAppName) throw new Error('sdk was initialized with a different firebase app');\n\n    return <SdkContext.Provider value={props.sdk} {...props} />;\n  };\n}\n\nfunction useSdk<Sdk extends FirebaseSdks>(SdkContext: React.Context<Sdk | undefined>): Sdk {\n  const sdk = React.useContext(SdkContext);\n\n  if (!sdk) {\n    throw new Error('SDK not found. useSdk must be called from within a provider');\n  }\n\n  return sdk;\n}\n\nfunction useInitSdk<Sdk extends FirebaseSdks>(\n  sdkName: string,\n  SdkContext: React.Context<Sdk | undefined>,\n  sdkInitializer: (firebaseApp: FirebaseApp) => Promise<Sdk>,\n  options?: ReactFireOptions\n) {\n  const firebaseApp = useFirebaseApp();\n\n  // Some initialization functions (like Firestore's `enableIndexedDbPersistence`)\n  // can only be called before anything else. So if an sdk is already available in context,\n  // it isn't safe to call initialization functions again.\n  if (React.useContext(SdkContext)) {\n    throw new Error(`Cannot initialize SDK ${sdkName} because it already exists in Context`);\n  }\n\n  const initializeSdk = React.useMemo(() => sdkInitializer(firebaseApp), [firebaseApp]);\n\n  return useObservable<Sdk>(`firebase-sdk:${sdkName}:${firebaseApp.name}`, from(initializeSdk), options);\n}\n\nexport const AppCheckProvider = getSdkProvider<AppCheck>(AppCheckSdkContext);\nexport const AuthProvider = getSdkProvider<Auth>(AuthSdkContext);\nexport const AnalyticsProvider = getSdkProvider<Analytics>(AnalyticsSdkContext);\nexport const DatabaseProvider = getSdkProvider<Database>(DatabaseSdkContext);\nexport const FirestoreProvider = getSdkProvider<Firestore>(FirestoreSdkContext);\nexport const FunctionsProvider = getSdkProvider<Functions>(FunctionsSdkContext);\nexport const PerformanceProvider = getSdkProvider<FirebasePerformance>(PerformanceSdkContext);\nexport const StorageProvider = getSdkProvider<FirebaseStorage>(StorageSdkContext);\nexport const RemoteConfigProvider = getSdkProvider<RemoteConfig>(RemoteConfigSdkContext);\n\nexport const useAppCheck = () => useSdk<AppCheck>(AppCheckSdkContext);\nexport const useAuth = () => useSdk<Auth>(AuthSdkContext);\nexport const useAnalytics = () => useSdk<Analytics>(AnalyticsSdkContext);\nexport const useDatabase = () => useSdk<Database>(DatabaseSdkContext);\nexport const useFirestore = () => useSdk<Firestore>(FirestoreSdkContext);\nexport const useFunctions = () => useSdk<Functions>(FunctionsSdkContext);\nexport const usePerformance = () => useSdk<FirebasePerformance>(PerformanceSdkContext);\nexport const useStorage = () => useSdk<FirebaseStorage>(StorageSdkContext);\nexport const useRemoteConfig = () => useSdk<RemoteConfig>(RemoteConfigSdkContext);\n\ntype InitSdkHook<Sdk extends FirebaseSdks> = (\n  initializer: (firebaseApp: FirebaseApp) => Promise<Sdk>,\n  options?: ReactFireOptions<Sdk>\n) => ObservableStatus<Sdk>;\n\nexport const useInitAppCheck: InitSdkHook<AppCheck> = (initializer, options) => useInitSdk<AppCheck>('appcheck', AppCheckSdkContext, initializer, options);\nexport const useInitAuth: InitSdkHook<Auth> = (initializer, options) => useInitSdk<Auth>('auth', AuthSdkContext, initializer, options);\nexport const useInitAnalytics: InitSdkHook<Analytics> = (initializer, options) => useInitSdk<Analytics>('analytics', AnalyticsSdkContext, initializer, options);\nexport const useInitDatabase: InitSdkHook<Database> = (initializer, options) => useInitSdk<Database>('database', DatabaseSdkContext, initializer, options);\nexport const useInitFirestore: InitSdkHook<Firestore> = (initializer, options) => useInitSdk<Firestore>('firestore', FirestoreSdkContext, initializer, options);\nexport const useInitFunctions: InitSdkHook<Functions> = (initializer, options) => useInitSdk<Functions>('functions', FunctionsSdkContext, initializer, options);\nexport const useInitPerformance: InitSdkHook<FirebasePerformance> = (initializer, options) =>\n  useInitSdk<FirebasePerformance>('performance', PerformanceSdkContext, initializer, options);\nexport const useInitRemoteConfig: InitSdkHook<RemoteConfig> = (initializer, options) =>\n  useInitSdk<RemoteConfig>('remoteconfig', RemoteConfigSdkContext, initializer, options);\nexport const useInitStorage: InitSdkHook<FirebaseStorage> = (initializer, options) =>\n  useInitSdk<FirebaseStorage>('storage', StorageSdkContext, initializer, options);\n","import { SuspenseSubject } from './SuspenseSubject';\n\nimport type { Query as FirestoreQuery } from 'firebase/firestore';\nimport type { Query as DatabaseQuery } from 'firebase/database';\n\nexport type ReactFireGlobals = {\n  _reactFireDatabaseCachedQueries: Array<DatabaseQuery>;\n  _reactFireFirestoreQueryCache: Array<FirestoreQuery>;\n  _reactFirePreloadedObservables: Map<string, SuspenseSubject<any>>;\n};\n\nexport class ReactFireError extends Error {\n  readonly name = 'ReactFireError';\n\n  constructor(readonly code: string, message: string, public customData?: Record<string, unknown>) {\n    super(message);\n\n    // Fix For ES5\n    // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, ReactFireError.prototype);\n  }\n}\n\nexport interface ReactFireOptions<T = unknown> {\n  idField?: string;\n  initialData?: T | any;\n  /**\n   * @deprecated use initialData instead\n   */\n  startWithValue?: T | any;\n  suspense?: boolean;\n}\n\nexport function checkOptions(options: ReactFireOptions, field: string) {\n  // make sure the field passed in is a valid key of ReactFire Options\n  if (field === 'idField' || field === 'initialData' || field === 'suspense') {\n    return options ? (options[field] as ReactFireOptions['idField'] | ReactFireOptions['initialData'] | ReactFireOptions['suspense']) : undefined;\n  }\n\n  throw new Error(`Field \"${field}\" is not a valid key in ReactFireOptions`);\n}\n\nexport function checkinitialData(options: ReactFireOptions) {\n  return checkOptions(options, 'initialData');\n}\n\nexport function checkIdField(options: ReactFireOptions) {\n  return checkOptions(options, 'idField');\n}\n\nexport * from './auth';\nexport * from './database';\nexport * from './firebaseApp';\nexport * from './firestore';\nexport * from './functions';\nexport * from './performance';\nexport * from './remote-config';\nexport * from './storage';\nexport * from './useObservable';\nexport * from './sdk';\n"]},"metadata":{},"sourceType":"module"}