{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { cloneNode } from './cloneNode';\nimport { embedImages } from './embedImages';\nimport { applyStyleWithOptions } from './applyStyleWithOptions';\nimport { embedWebFonts, getWebFontCSS } from './embedWebFonts';\nimport { getNodeWidth, getNodeHeight, getPixelRatio, createImage, canvasToBlob, nodeToDataURL } from './util';\n\nfunction getImageSize(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const width = options.width || getNodeWidth(node);\n  const height = options.height || getNodeHeight(node);\n  return {\n    width,\n    height\n  };\n}\n\nexport function toSvg(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      width,\n      height\n    } = getImageSize(node, options);\n    return Promise.resolve(node).then(nativeNode => cloneNode(nativeNode, options, true)).then(clonedNode => embedWebFonts(clonedNode, options)).then(clonedNode => embedImages(clonedNode, options)).then(clonedNode => applyStyleWithOptions(clonedNode, options)).then(clonedNode => nodeToDataURL(clonedNode, width, height));\n  });\n}\nconst dimensionCanvasLimit = 16384; // as per https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\n\nfunction checkCanvasDimensions(canvas) {\n  if (canvas.width > dimensionCanvasLimit || canvas.height > dimensionCanvasLimit) {\n    if (canvas.width > dimensionCanvasLimit && canvas.height > dimensionCanvasLimit) {\n      if (canvas.width > canvas.height) {\n        canvas.height *= dimensionCanvasLimit / canvas.width;\n        canvas.width = dimensionCanvasLimit;\n      } else {\n        canvas.width *= dimensionCanvasLimit / canvas.height;\n        canvas.height = dimensionCanvasLimit;\n      }\n    } else if (canvas.width > dimensionCanvasLimit) {\n      canvas.height *= dimensionCanvasLimit / canvas.width;\n      canvas.width = dimensionCanvasLimit;\n    } else {\n      canvas.width *= dimensionCanvasLimit / canvas.height;\n      canvas.height = dimensionCanvasLimit;\n    }\n  }\n}\n\nexport function toCanvas(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __awaiter(this, void 0, void 0, function* () {\n    return toSvg(node, options).then(createImage).then(img => {\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext('2d');\n      const ratio = options.pixelRatio || getPixelRatio();\n      const {\n        width,\n        height\n      } = getImageSize(node, options);\n      const canvasWidth = options.canvasWidth || width;\n      const canvasHeight = options.canvasHeight || height;\n      canvas.width = canvasWidth * ratio;\n      canvas.height = canvasHeight * ratio;\n\n      if (!options.skipAutoScale) {\n        checkCanvasDimensions(canvas);\n      }\n\n      canvas.style.width = `${canvasWidth}`;\n      canvas.style.height = `${canvasHeight}`;\n\n      if (options.backgroundColor) {\n        context.fillStyle = options.backgroundColor;\n        context.fillRect(0, 0, canvas.width, canvas.height);\n      }\n\n      context.drawImage(img, 0, 0, canvas.width, canvas.height);\n      return canvas;\n    });\n  });\n}\nexport function toPixelData(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      width,\n      height\n    } = getImageSize(node, options);\n    return toCanvas(node, options).then(canvas => {\n      const ctx = canvas.getContext('2d');\n      return ctx.getImageData(0, 0, width, height).data;\n    });\n  });\n}\nexport function toPng(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __awaiter(this, void 0, void 0, function* () {\n    return toCanvas(node, options).then(canvas => canvas.toDataURL());\n  });\n}\nexport function toJpeg(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __awaiter(this, void 0, void 0, function* () {\n    return toCanvas(node, options).then(canvas => canvas.toDataURL('image/jpeg', options.quality || 1));\n  });\n}\nexport function toBlob(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __awaiter(this, void 0, void 0, function* () {\n    return toCanvas(node, options).then(canvasToBlob);\n  });\n}\nexport function getFontEmbedCSS(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __awaiter(this, void 0, void 0, function* () {\n    return getWebFontCSS(node, options);\n  });\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { cloneNode } from './cloneNode';\nimport { embedImages } from './embedImages';\nimport { applyStyleWithOptions } from './applyStyleWithOptions';\nimport { embedWebFonts, getWebFontCSS } from './embedWebFonts';\nimport { getNodeWidth, getNodeHeight, getPixelRatio, createImage, canvasToBlob, nodeToDataURL, } from './util';\nfunction getImageSize(node, options = {}) {\n    const width = options.width || getNodeWidth(node);\n    const height = options.height || getNodeHeight(node);\n    return { width, height };\n}\nexport function toSvg(node, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { width, height } = getImageSize(node, options);\n        return Promise.resolve(node)\n            .then((nativeNode) => cloneNode(nativeNode, options, true))\n            .then((clonedNode) => embedWebFonts(clonedNode, options))\n            .then((clonedNode) => embedImages(clonedNode, options))\n            .then((clonedNode) => applyStyleWithOptions(clonedNode, options))\n            .then((clonedNode) => nodeToDataURL(clonedNode, width, height));\n    });\n}\nconst dimensionCanvasLimit = 16384; // as per https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nfunction checkCanvasDimensions(canvas) {\n    if (canvas.width > dimensionCanvasLimit ||\n        canvas.height > dimensionCanvasLimit) {\n        if (canvas.width > dimensionCanvasLimit &&\n            canvas.height > dimensionCanvasLimit) {\n            if (canvas.width > canvas.height) {\n                canvas.height *= dimensionCanvasLimit / canvas.width;\n                canvas.width = dimensionCanvasLimit;\n            }\n            else {\n                canvas.width *= dimensionCanvasLimit / canvas.height;\n                canvas.height = dimensionCanvasLimit;\n            }\n        }\n        else if (canvas.width > dimensionCanvasLimit) {\n            canvas.height *= dimensionCanvasLimit / canvas.width;\n            canvas.width = dimensionCanvasLimit;\n        }\n        else {\n            canvas.width *= dimensionCanvasLimit / canvas.height;\n            canvas.height = dimensionCanvasLimit;\n        }\n    }\n}\nexport function toCanvas(node, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return toSvg(node, options)\n            .then(createImage)\n            .then((img) => {\n            const canvas = document.createElement('canvas');\n            const context = canvas.getContext('2d');\n            const ratio = options.pixelRatio || getPixelRatio();\n            const { width, height } = getImageSize(node, options);\n            const canvasWidth = options.canvasWidth || width;\n            const canvasHeight = options.canvasHeight || height;\n            canvas.width = canvasWidth * ratio;\n            canvas.height = canvasHeight * ratio;\n            if (!options.skipAutoScale) {\n                checkCanvasDimensions(canvas);\n            }\n            canvas.style.width = `${canvasWidth}`;\n            canvas.style.height = `${canvasHeight}`;\n            if (options.backgroundColor) {\n                context.fillStyle = options.backgroundColor;\n                context.fillRect(0, 0, canvas.width, canvas.height);\n            }\n            context.drawImage(img, 0, 0, canvas.width, canvas.height);\n            return canvas;\n        });\n    });\n}\nexport function toPixelData(node, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { width, height } = getImageSize(node, options);\n        return toCanvas(node, options).then((canvas) => {\n            const ctx = canvas.getContext('2d');\n            return ctx.getImageData(0, 0, width, height).data;\n        });\n    });\n}\nexport function toPng(node, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return toCanvas(node, options).then((canvas) => canvas.toDataURL());\n    });\n}\nexport function toJpeg(node, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return toCanvas(node, options).then((canvas) => canvas.toDataURL('image/jpeg', options.quality || 1));\n    });\n}\nexport function toBlob(node, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return toCanvas(node, options).then(canvasToBlob);\n    });\n}\nexport function getFontEmbedCSS(node, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return getWebFontCSS(node, options);\n    });\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}