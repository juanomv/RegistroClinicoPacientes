{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { toArray } from './util';\nimport { shouldEmbed, embedResources } from './embedResources';\nconst cssFetchCache = {};\n\nfunction fetchCSS(url) {\n  const cache = cssFetchCache[url];\n\n  if (cache != null) {\n    return cache;\n  }\n\n  const deferred = window.fetch(url).then(res => ({\n    url,\n    cssText: res.text()\n  }));\n  cssFetchCache[url] = deferred;\n  return deferred;\n}\n\nfunction embedFonts(meta) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return meta.cssText.then(raw => {\n      let cssText = raw;\n      const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n      const fontLocs = cssText.match(/url\\([^)]+\\)/g) || [];\n      const loadFonts = fontLocs.map(location => {\n        let url = location.replace(regexUrl, '$1');\n\n        if (!url.startsWith('https://')) {\n          url = new URL(url, meta.url).href;\n        } // eslint-disable-next-line promise/no-nesting\n\n\n        return window.fetch(url).then(res => res.blob()).then(blob => new Promise((resolve, reject) => {\n          const reader = new FileReader();\n\n          reader.onloadend = () => {\n            // Side Effect\n            cssText = cssText.replace(location, `url(${reader.result})`);\n            resolve([location, reader.result]);\n          };\n\n          reader.onerror = reject;\n          reader.readAsDataURL(blob);\n        }));\n      }); // eslint-disable-next-line promise/no-nesting\n\n      return Promise.all(loadFonts).then(() => cssText);\n    });\n  });\n}\n\nfunction parseCSS(source) {\n  if (source == null) {\n    return [];\n  }\n\n  const result = [];\n  const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi; // strip out comments\n\n  let cssText = source.replace(commentsRegex, '');\n  const keyframesRegex = new RegExp('((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})', 'gi'); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    const matches = keyframesRegex.exec(cssText);\n\n    if (matches === null) {\n      break;\n    }\n\n    result.push(matches[0]);\n  }\n\n  cssText = cssText.replace(keyframesRegex, '');\n  const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi; // to match css & media queries together\n\n  const combinedCSSRegex = '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' + '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})'; // unified regex\n\n  const unifiedRegex = new RegExp(combinedCSSRegex, 'gi'); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    let matches = importRegex.exec(cssText);\n\n    if (matches === null) {\n      matches = unifiedRegex.exec(cssText);\n\n      if (matches === null) {\n        break;\n      } else {\n        importRegex.lastIndex = unifiedRegex.lastIndex;\n      }\n    } else {\n      unifiedRegex.lastIndex = importRegex.lastIndex;\n    }\n\n    result.push(matches[0]);\n  }\n\n  return result;\n}\n\nfunction getCSSRules(styleSheets) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const ret = [];\n    const deferreds = []; // First loop inlines imports\n\n    styleSheets.forEach(sheet => {\n      if ('cssRules' in sheet) {\n        try {\n          toArray(sheet.cssRules).forEach((item, index) => {\n            if (item.type === CSSRule.IMPORT_RULE) {\n              let importIndex = index + 1;\n              const url = item.href;\n              const deferred = fetchCSS(url).then(metadata => metadata ? embedFonts(metadata) : '').then(cssText => parseCSS(cssText).forEach(rule => {\n                try {\n                  sheet.insertRule(rule, rule.startsWith('@import') ? importIndex += 1 : sheet.cssRules.length);\n                } catch (error) {\n                  console.error('Error inserting rule from remote css', {\n                    rule,\n                    error\n                  });\n                }\n              })).catch(e => {\n                console.error('Error loading remote css', e.toString());\n              });\n              deferreds.push(deferred);\n            }\n          });\n        } catch (e) {\n          const inline = styleSheets.find(a => a.href == null) || document.styleSheets[0];\n\n          if (sheet.href != null) {\n            deferreds.push(fetchCSS(sheet.href).then(metadata => metadata ? embedFonts(metadata) : '').then(cssText => parseCSS(cssText).forEach(rule => {\n              inline.insertRule(rule, sheet.cssRules.length);\n            })).catch(err => {\n              console.error('Error loading remote stylesheet', err.toString());\n            }));\n          }\n\n          console.error('Error inlining remote css file', e.toString());\n        }\n      }\n    });\n    return Promise.all(deferreds).then(() => {\n      // Second loop parses rules\n      styleSheets.forEach(sheet => {\n        if ('cssRules' in sheet) {\n          try {\n            toArray(sheet.cssRules).forEach(item => {\n              ret.push(item);\n            });\n          } catch (e) {\n            console.error(`Error while reading CSS rules from ${sheet.href}`, e.toString());\n          }\n        }\n      });\n      return ret;\n    });\n  });\n}\n\nfunction getWebFontRules(cssRules) {\n  return cssRules.filter(rule => rule.type === CSSRule.FONT_FACE_RULE).filter(rule => shouldEmbed(rule.style.getPropertyValue('src')));\n}\n\nfunction parseWebFontRules(node) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      if (node.ownerDocument == null) {\n        reject(new Error('Provided element is not within a Document'));\n      }\n\n      resolve(toArray(node.ownerDocument.styleSheets));\n    }).then(styleSheets => getCSSRules(styleSheets)).then(getWebFontRules);\n  });\n}\n\nexport function getWebFontCSS(node, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return parseWebFontRules(node).then(rules => Promise.all(rules.map(rule => {\n      const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;\n      return embedResources(rule.cssText, baseUrl, options);\n    }))).then(cssTexts => cssTexts.join('\\n'));\n  });\n}\nexport function embedWebFonts(clonedNode, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return (options.fontEmbedCSS != null ? Promise.resolve(options.fontEmbedCSS) : getWebFontCSS(clonedNode, options)).then(cssText => {\n      const styleNode = document.createElement('style');\n      const sytleContent = document.createTextNode(cssText);\n      styleNode.appendChild(sytleContent);\n\n      if (clonedNode.firstChild) {\n        clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n      } else {\n        clonedNode.appendChild(styleNode);\n      }\n\n      return clonedNode;\n    });\n  });\n}","map":{"version":3,"sources":["../src/embedWebFonts.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { toArray } from './util';\nimport { shouldEmbed, embedResources } from './embedResources';\nconst cssFetchCache = {};\nfunction fetchCSS(url) {\n    const cache = cssFetchCache[url];\n    if (cache != null) {\n        return cache;\n    }\n    const deferred = window.fetch(url).then((res) => ({\n        url,\n        cssText: res.text(),\n    }));\n    cssFetchCache[url] = deferred;\n    return deferred;\n}\nfunction embedFonts(meta) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return meta.cssText.then((raw) => {\n            let cssText = raw;\n            const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n            const fontLocs = cssText.match(/url\\([^)]+\\)/g) || [];\n            const loadFonts = fontLocs.map((location) => {\n                let url = location.replace(regexUrl, '$1');\n                if (!url.startsWith('https://')) {\n                    url = new URL(url, meta.url).href;\n                }\n                // eslint-disable-next-line promise/no-nesting\n                return window\n                    .fetch(url)\n                    .then((res) => res.blob())\n                    .then((blob) => new Promise((resolve, reject) => {\n                    const reader = new FileReader();\n                    reader.onloadend = () => {\n                        // Side Effect\n                        cssText = cssText.replace(location, `url(${reader.result})`);\n                        resolve([location, reader.result]);\n                    };\n                    reader.onerror = reject;\n                    reader.readAsDataURL(blob);\n                }));\n            });\n            // eslint-disable-next-line promise/no-nesting\n            return Promise.all(loadFonts).then(() => cssText);\n        });\n    });\n}\nfunction parseCSS(source) {\n    if (source == null) {\n        return [];\n    }\n    const result = [];\n    const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi;\n    // strip out comments\n    let cssText = source.replace(commentsRegex, '');\n    const keyframesRegex = new RegExp('((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})', 'gi');\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const matches = keyframesRegex.exec(cssText);\n        if (matches === null) {\n            break;\n        }\n        result.push(matches[0]);\n    }\n    cssText = cssText.replace(keyframesRegex, '');\n    const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n    // to match css & media queries together\n    const combinedCSSRegex = '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\n        '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})';\n    // unified regex\n    const unifiedRegex = new RegExp(combinedCSSRegex, 'gi');\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        let matches = importRegex.exec(cssText);\n        if (matches === null) {\n            matches = unifiedRegex.exec(cssText);\n            if (matches === null) {\n                break;\n            }\n            else {\n                importRegex.lastIndex = unifiedRegex.lastIndex;\n            }\n        }\n        else {\n            unifiedRegex.lastIndex = importRegex.lastIndex;\n        }\n        result.push(matches[0]);\n    }\n    return result;\n}\nfunction getCSSRules(styleSheets) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const ret = [];\n        const deferreds = [];\n        // First loop inlines imports\n        styleSheets.forEach((sheet) => {\n            if ('cssRules' in sheet) {\n                try {\n                    toArray(sheet.cssRules).forEach((item, index) => {\n                        if (item.type === CSSRule.IMPORT_RULE) {\n                            let importIndex = index + 1;\n                            const url = item.href;\n                            const deferred = fetchCSS(url)\n                                .then((metadata) => (metadata ? embedFonts(metadata) : ''))\n                                .then((cssText) => parseCSS(cssText).forEach((rule) => {\n                                try {\n                                    sheet.insertRule(rule, rule.startsWith('@import')\n                                        ? (importIndex += 1)\n                                        : sheet.cssRules.length);\n                                }\n                                catch (error) {\n                                    console.error('Error inserting rule from remote css', {\n                                        rule,\n                                        error,\n                                    });\n                                }\n                            }))\n                                .catch((e) => {\n                                console.error('Error loading remote css', e.toString());\n                            });\n                            deferreds.push(deferred);\n                        }\n                    });\n                }\n                catch (e) {\n                    const inline = styleSheets.find((a) => a.href == null) || document.styleSheets[0];\n                    if (sheet.href != null) {\n                        deferreds.push(fetchCSS(sheet.href)\n                            .then((metadata) => (metadata ? embedFonts(metadata) : ''))\n                            .then((cssText) => parseCSS(cssText).forEach((rule) => {\n                            inline.insertRule(rule, sheet.cssRules.length);\n                        }))\n                            .catch((err) => {\n                            console.error('Error loading remote stylesheet', err.toString());\n                        }));\n                    }\n                    console.error('Error inlining remote css file', e.toString());\n                }\n            }\n        });\n        return Promise.all(deferreds).then(() => {\n            // Second loop parses rules\n            styleSheets.forEach((sheet) => {\n                if ('cssRules' in sheet) {\n                    try {\n                        toArray(sheet.cssRules).forEach((item) => {\n                            ret.push(item);\n                        });\n                    }\n                    catch (e) {\n                        console.error(`Error while reading CSS rules from ${sheet.href}`, e.toString());\n                    }\n                }\n            });\n            return ret;\n        });\n    });\n}\nfunction getWebFontRules(cssRules) {\n    return cssRules\n        .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n        .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')));\n}\nfunction parseWebFontRules(node) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            if (node.ownerDocument == null) {\n                reject(new Error('Provided element is not within a Document'));\n            }\n            resolve(toArray(node.ownerDocument.styleSheets));\n        })\n            .then((styleSheets) => getCSSRules(styleSheets))\n            .then(getWebFontRules);\n    });\n}\nexport function getWebFontCSS(node, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return parseWebFontRules(node)\n            .then((rules) => Promise.all(rules.map((rule) => {\n            const baseUrl = rule.parentStyleSheet\n                ? rule.parentStyleSheet.href\n                : null;\n            return embedResources(rule.cssText, baseUrl, options);\n        })))\n            .then((cssTexts) => cssTexts.join('\\n'));\n    });\n}\nexport function embedWebFonts(clonedNode, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return (options.fontEmbedCSS != null\n            ? Promise.resolve(options.fontEmbedCSS)\n            : getWebFontCSS(clonedNode, options)).then((cssText) => {\n            const styleNode = document.createElement('style');\n            const sytleContent = document.createTextNode(cssText);\n            styleNode.appendChild(sytleContent);\n            if (clonedNode.firstChild) {\n                clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n            }\n            else {\n                clonedNode.appendChild(styleNode);\n            }\n            return clonedNode;\n        });\n    });\n}\n//# sourceMappingURL=embedWebFonts.js.map"]},"metadata":{},"sourceType":"module"}