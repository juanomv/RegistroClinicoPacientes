{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { getBlobFromURL } from './getBlobFromURL';\nimport { clonePseudoElements } from './clonePseudoElements';\nimport { createImage, getMimeType, makeDataUrl, toArray } from './util';\n\nfunction cloneCanvasElement(node) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const dataURL = node.toDataURL();\n\n    if (dataURL === 'data:,') {\n      return Promise.resolve(node.cloneNode(false));\n    }\n\n    return createImage(dataURL);\n  });\n}\n\nfunction cloneVideoElement(node, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return Promise.resolve(node.poster).then(url => getBlobFromURL(url, options)).then(data => makeDataUrl(data.blob, getMimeType(node.poster) || data.contentType)).then(dataURL => createImage(dataURL));\n  });\n}\n\nfunction cloneSingleNode(node, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (node instanceof HTMLCanvasElement) {\n      return cloneCanvasElement(node);\n    }\n\n    if (node instanceof HTMLVideoElement && node.poster) {\n      return cloneVideoElement(node, options);\n    }\n\n    return Promise.resolve(node.cloneNode(false));\n  });\n}\n\nconst isSlotElement = node => node.tagName != null && node.tagName.toUpperCase() === 'SLOT';\n\nfunction cloneChildren(nativeNode, clonedNode, options) {\n  var _a;\n\n  return __awaiter(this, void 0, void 0, function* () {\n    const children = isSlotElement(nativeNode) && nativeNode.assignedNodes ? toArray(nativeNode.assignedNodes()) : toArray(((_a = nativeNode.shadowRoot) !== null && _a !== void 0 ? _a : nativeNode).childNodes);\n\n    if (children.length === 0 || nativeNode instanceof HTMLVideoElement) {\n      return Promise.resolve(clonedNode);\n    }\n\n    return children.reduce((deferred, child) => deferred // eslint-disable-next-line no-use-before-define\n    .then(() => cloneNode(child, options)).then(clonedChild => {\n      // eslint-disable-next-line promise/always-return\n      if (clonedChild) {\n        clonedNode.appendChild(clonedChild);\n      }\n    }), Promise.resolve()).then(() => clonedNode);\n  });\n}\n\nfunction cloneCSSStyle(nativeNode, clonedNode) {\n  const source = window.getComputedStyle(nativeNode);\n  const target = clonedNode.style;\n\n  if (!target) {\n    return;\n  }\n\n  if (source.cssText) {\n    target.cssText = source.cssText;\n  } else {\n    toArray(source).forEach(name => {\n      target.setProperty(name, source.getPropertyValue(name), source.getPropertyPriority(name));\n    });\n  }\n}\n\nfunction cloneInputValue(nativeNode, clonedNode) {\n  if (nativeNode instanceof HTMLTextAreaElement) {\n    clonedNode.innerHTML = nativeNode.value;\n  }\n\n  if (nativeNode instanceof HTMLInputElement) {\n    clonedNode.setAttribute('value', nativeNode.value);\n  }\n}\n\nfunction decorate(nativeNode, clonedNode) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!(clonedNode instanceof Element)) {\n      return Promise.resolve(clonedNode);\n    }\n\n    return Promise.resolve().then(() => cloneCSSStyle(nativeNode, clonedNode)).then(() => clonePseudoElements(nativeNode, clonedNode)).then(() => cloneInputValue(nativeNode, clonedNode)).then(() => clonedNode);\n  });\n}\n\nexport function cloneNode(node, options, isRoot) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!isRoot && options.filter && !options.filter(node)) {\n      return Promise.resolve(null);\n    }\n\n    return Promise.resolve(node).then(clonedNode => cloneSingleNode(clonedNode, options)).then(clonedNode => cloneChildren(node, clonedNode, options)).then(clonedNode => decorate(node, clonedNode));\n  });\n}","map":{"version":3,"sources":["../src/cloneNode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getBlobFromURL } from './getBlobFromURL';\nimport { clonePseudoElements } from './clonePseudoElements';\nimport { createImage, getMimeType, makeDataUrl, toArray } from './util';\nfunction cloneCanvasElement(node) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const dataURL = node.toDataURL();\n        if (dataURL === 'data:,') {\n            return Promise.resolve(node.cloneNode(false));\n        }\n        return createImage(dataURL);\n    });\n}\nfunction cloneVideoElement(node, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return Promise.resolve(node.poster)\n            .then((url) => getBlobFromURL(url, options))\n            .then((data) => makeDataUrl(data.blob, getMimeType(node.poster) || data.contentType))\n            .then((dataURL) => createImage(dataURL));\n    });\n}\nfunction cloneSingleNode(node, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (node instanceof HTMLCanvasElement) {\n            return cloneCanvasElement(node);\n        }\n        if (node instanceof HTMLVideoElement && node.poster) {\n            return cloneVideoElement(node, options);\n        }\n        return Promise.resolve(node.cloneNode(false));\n    });\n}\nconst isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === 'SLOT';\nfunction cloneChildren(nativeNode, clonedNode, options) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        const children = isSlotElement(nativeNode) && nativeNode.assignedNodes\n            ? toArray(nativeNode.assignedNodes())\n            : toArray(((_a = nativeNode.shadowRoot) !== null && _a !== void 0 ? _a : nativeNode).childNodes);\n        if (children.length === 0 || nativeNode instanceof HTMLVideoElement) {\n            return Promise.resolve(clonedNode);\n        }\n        return children\n            .reduce((deferred, child) => deferred\n            // eslint-disable-next-line no-use-before-define\n            .then(() => cloneNode(child, options))\n            .then((clonedChild) => {\n            // eslint-disable-next-line promise/always-return\n            if (clonedChild) {\n                clonedNode.appendChild(clonedChild);\n            }\n        }), Promise.resolve())\n            .then(() => clonedNode);\n    });\n}\nfunction cloneCSSStyle(nativeNode, clonedNode) {\n    const source = window.getComputedStyle(nativeNode);\n    const target = clonedNode.style;\n    if (!target) {\n        return;\n    }\n    if (source.cssText) {\n        target.cssText = source.cssText;\n    }\n    else {\n        toArray(source).forEach((name) => {\n            target.setProperty(name, source.getPropertyValue(name), source.getPropertyPriority(name));\n        });\n    }\n}\nfunction cloneInputValue(nativeNode, clonedNode) {\n    if (nativeNode instanceof HTMLTextAreaElement) {\n        clonedNode.innerHTML = nativeNode.value;\n    }\n    if (nativeNode instanceof HTMLInputElement) {\n        clonedNode.setAttribute('value', nativeNode.value);\n    }\n}\nfunction decorate(nativeNode, clonedNode) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!(clonedNode instanceof Element)) {\n            return Promise.resolve(clonedNode);\n        }\n        return Promise.resolve()\n            .then(() => cloneCSSStyle(nativeNode, clonedNode))\n            .then(() => clonePseudoElements(nativeNode, clonedNode))\n            .then(() => cloneInputValue(nativeNode, clonedNode))\n            .then(() => clonedNode);\n    });\n}\nexport function cloneNode(node, options, isRoot) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!isRoot && options.filter && !options.filter(node)) {\n            return Promise.resolve(null);\n        }\n        return Promise.resolve(node)\n            .then((clonedNode) => cloneSingleNode(clonedNode, options))\n            .then((clonedNode) => cloneChildren(node, clonedNode, options))\n            .then((clonedNode) => decorate(node, clonedNode));\n    });\n}\n//# sourceMappingURL=cloneNode.js.map"]},"metadata":{},"sourceType":"module"}