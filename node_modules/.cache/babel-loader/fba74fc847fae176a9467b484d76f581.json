{"ast":null,"code":"import { __spreadArray } from 'tslib';\nimport { onSnapshot, refEqual } from 'firebase/firestore';\nimport { Observable, pipe } from 'rxjs';\nimport { map, startWith, pairwise, filter, scan, distinctUntilChanged } from 'rxjs/operators';\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar DEFAULT_OPTIONS = {\n  includeMetadataChanges: false\n};\n\nfunction fromRef(ref, options) {\n  if (options === void 0) {\n    options = DEFAULT_OPTIONS;\n  }\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n\n\n  return new Observable(function (subscriber) {\n    var unsubscribe = onSnapshot(ref, options, {\n      next: subscriber.next.bind(subscriber),\n      error: subscriber.error.bind(subscriber),\n      complete: subscriber.complete.bind(subscriber)\n    });\n    return {\n      unsubscribe: unsubscribe\n    };\n  });\n}\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nfunction doc(ref) {\n  return fromRef(ref, {\n    includeMetadataChanges: true\n  });\n}\n/**\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\n * @param query\n */\n\n\nfunction docData(ref, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return doc(ref).pipe(map(function (snap) {\n    return snapToData(snap, options);\n  }));\n}\n\nfunction snapToData(snapshot, options) {\n  if (options === void 0) {\n    options = {};\n  } // TODO clean up the typings\n\n\n  var data = snapshot.data(); // match the behavior of the JS SDK when the snapshot doesn't exist\n  // it's possible with data converters too that the user didn't return an object\n\n  if (!snapshot.exists() || typeof data !== 'object' || data === null) {\n    return data;\n  }\n\n  if (options.idField) {\n    data[options.idField] = snapshot.id;\n  }\n\n  return data;\n}\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar ALL_EVENTS = ['added', 'modified', 'removed'];\n/**\n * Create an operator that determines if a the stream of document changes\n * are specified by the event filter. If the document change type is not\n * in specified events array, it will not be emitted.\n */\n\nvar filterEvents = function (events) {\n  return filter(function (changes) {\n    var hasChange = false;\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n\n      if (events && events.indexOf(change.type) >= 0) {\n        hasChange = true;\n        break;\n      }\n    }\n\n    return hasChange;\n  });\n};\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\n\n\nfunction sliceAndSplice(original, start, deleteCount) {\n  var args = [];\n\n  for (var _i = 3; _i < arguments.length; _i++) {\n    args[_i - 3] = arguments[_i];\n  }\n\n  var returnArray = original.slice();\n  returnArray.splice.apply(returnArray, __spreadArray([start, deleteCount], args));\n  return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\n\n\nfunction processIndividualChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && refEqual(combined[change.newIndex].doc.ref, change.doc.ref)) ;else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n\n    case 'modified':\n      if (combined[change.oldIndex] == null || refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          var copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n\n      break;\n\n    case 'removed':\n      if (combined[change.oldIndex] && refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n\n      break;\n  }\n\n  return combined;\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\n\n\nfunction processDocumentChanges(current, changes, events) {\n  if (events === void 0) {\n    events = ALL_EVENTS;\n  }\n\n  changes.forEach(function (change) {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = processIndividualChange(current, change);\n    }\n  });\n  return current;\n}\n/**\n * Create an operator that allows you to compare the current emission with\n * the prior, even on first emission (where prior is undefined).\n */\n\n\nvar windowwise = function () {\n  return pipe(startWith(undefined), pairwise());\n};\n/**\n * Given two snapshots does their metadata match?\n * @param a\n * @param b\n */\n\n\nvar metaDataEquals = function (a, b) {\n  return JSON.stringify(a.metadata) === JSON.stringify(b.metadata);\n};\n/**\n * Create an operator that filters out empty changes. We provide the\n * ability to filter on events, which means all changes can be filtered out.\n * This creates an empty array and would be incorrect to emit.\n */\n\n\nvar filterEmptyUnlessFirst = function () {\n  return pipe(windowwise(), filter(function (_a) {\n    var prior = _a[0],\n        current = _a[1];\n    return current.length > 0 || prior === undefined;\n  }), map(function (_a) {\n    _a[0];\n    var current = _a[1];\n    return current;\n  }));\n};\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\n\n\nfunction collectionChanges(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return fromRef(query, {\n    includeMetadataChanges: true\n  }).pipe(windowwise(), map(function (_a) {\n    var priorSnapshot = _a[0],\n        currentSnapshot = _a[1];\n    var docChanges = currentSnapshot.docChanges();\n\n    if (priorSnapshot && !metaDataEquals(priorSnapshot, currentSnapshot)) {\n      // the metadata has changed, docChanges() doesn't return metadata events, so let's\n      // do it ourselves by scanning over all the docs and seeing if the metadata has changed\n      // since either this docChanges() emission or the prior snapshot\n      currentSnapshot.docs.forEach(function (currentDocSnapshot, currentIndex) {\n        var currentDocChange = docChanges.find(function (c) {\n          return refEqual(c.doc.ref, currentDocSnapshot.ref);\n        });\n\n        if (currentDocChange) {\n          // if the doc is in the current changes and the metadata hasn't changed this doc\n          if (metaDataEquals(currentDocChange.doc, currentDocSnapshot)) {\n            return;\n          }\n        } else {\n          // if there is a prior doc and the metadata hasn't changed skip this doc\n          var priorDocSnapshot = priorSnapshot === null || priorSnapshot === void 0 ? void 0 : priorSnapshot.docs.find(function (d) {\n            return refEqual(d.ref, currentDocSnapshot.ref);\n          });\n\n          if (priorDocSnapshot && metaDataEquals(priorDocSnapshot, currentDocSnapshot)) {\n            return;\n          }\n        }\n\n        docChanges.push({\n          oldIndex: currentIndex,\n          newIndex: currentIndex,\n          type: 'modified',\n          doc: currentDocSnapshot\n        });\n      });\n    }\n\n    return docChanges;\n  }), filterEvents(options.events || ALL_EVENTS), filterEmptyUnlessFirst());\n}\n/**\n * Return a stream of document snapshots on a query. These results are in sort order.\n * @param query\n */\n\n\nfunction collection(query) {\n  return fromRef(query, {\n    includeMetadataChanges: true\n  }).pipe(map(function (changes) {\n    return changes.docs;\n  }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\n\n\nfunction sortedChanges(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return collectionChanges(query, options).pipe(scan(function (current, changes) {\n    return processDocumentChanges(current, changes, options.events);\n  }, []), distinctUntilChanged());\n}\n/**\n * Create a stream of changes as they occur it time. This method is similar\n * to docChanges() but it collects each event in an array over time.\n */\n\n\nfunction auditTrail(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return collectionChanges(query, options).pipe(scan(function (current, action) {\n    return __spreadArray(__spreadArray([], current), action);\n  }, []));\n}\n/**\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\n * @param query\n */\n\n\nfunction collectionData(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return collection(query).pipe(map(function (arr) {\n    return arr.map(function (snap) {\n      return snapToData(snap, options);\n    });\n  }));\n}\n\nexport { auditTrail, collection, collectionChanges, collectionData, doc, docData, fromRef, snapToData, sortedChanges };","map":{"version":3,"sources":["../../firestore/fromRef.ts","../../firestore/document/index.ts","../../firestore/collection/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO figure out what is wrong with the types...\nimport { onSnapshot } from 'firebase/firestore';\nimport { Observable } from 'rxjs';\nvar DEFAULT_OPTIONS = { includeMetadataChanges: false };\nexport function fromRef(ref, options) {\n    if (options === void 0) { options = DEFAULT_OPTIONS; }\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n    return new Observable(function (subscriber) {\n        var unsubscribe = onSnapshot(ref, options, {\n            next: subscriber.next.bind(subscriber),\n            error: subscriber.error.bind(subscriber),\n            complete: subscriber.complete.bind(subscriber),\n        });\n        return { unsubscribe: unsubscribe };\n    });\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { fromRef } from '../fromRef';\nimport { map } from 'rxjs/operators';\nexport function doc(ref) {\n    return fromRef(ref, { includeMetadataChanges: true });\n}\n/**\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\n * @param query\n */\nexport function docData(ref, options) {\n    if (options === void 0) { options = {}; }\n    return doc(ref).pipe(map(function (snap) { return snapToData(snap, options); }));\n}\nexport function snapToData(snapshot, options) {\n    if (options === void 0) { options = {}; }\n    // TODO clean up the typings\n    var data = snapshot.data();\n    // match the behavior of the JS SDK when the snapshot doesn't exist\n    // it's possible with data converters too that the user didn't return an object\n    if (!snapshot.exists() || typeof data !== 'object' || data === null) {\n        return data;\n    }\n    if (options.idField) {\n        data[options.idField] = snapshot.id;\n    }\n    return data;\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __spreadArray } from \"tslib\";\nimport { fromRef } from '../fromRef';\nimport { pipe } from 'rxjs';\nimport { map, filter, scan, distinctUntilChanged, startWith, pairwise } from 'rxjs/operators';\nimport { snapToData } from '../document';\nimport { refEqual } from 'firebase/firestore';\nvar ALL_EVENTS = ['added', 'modified', 'removed'];\n/**\n * Create an operator that determines if a the stream of document changes\n * are specified by the event filter. If the document change type is not\n * in specified events array, it will not be emitted.\n */\nvar filterEvents = function (events) {\n    return filter(function (changes) {\n        var hasChange = false;\n        for (var i = 0; i < changes.length; i++) {\n            var change = changes[i];\n            if (events && events.indexOf(change.type) >= 0) {\n                hasChange = true;\n                break;\n            }\n        }\n        return hasChange;\n    });\n};\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice(original, start, deleteCount) {\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n        args[_i - 3] = arguments[_i];\n    }\n    var returnArray = original.slice();\n    returnArray.splice.apply(returnArray, __spreadArray([start, deleteCount], args));\n    return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\nfunction processIndividualChange(combined, change) {\n    switch (change.type) {\n        case 'added':\n            if (combined[change.newIndex] &&\n                refEqual(combined[change.newIndex].doc.ref, change.doc.ref)) {\n                // Skip duplicate emissions. This is rare.\n                // TODO: Investigate possible bug in SDK.\n            }\n            else {\n                return sliceAndSplice(combined, change.newIndex, 0, change);\n            }\n            break;\n        case 'modified':\n            if (combined[change.oldIndex] == null ||\n                refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n                // When an item changes position we first remove it\n                // and then add it's new position\n                if (change.oldIndex !== change.newIndex) {\n                    var copiedArray = combined.slice();\n                    copiedArray.splice(change.oldIndex, 1);\n                    copiedArray.splice(change.newIndex, 0, change);\n                    return copiedArray;\n                }\n                else {\n                    return sliceAndSplice(combined, change.newIndex, 1, change);\n                }\n            }\n            break;\n        case 'removed':\n            if (combined[change.oldIndex] &&\n                refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n                return sliceAndSplice(combined, change.oldIndex, 1);\n            }\n            break;\n        default: // ignore\n    }\n    return combined;\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\nfunction processDocumentChanges(current, changes, events) {\n    if (events === void 0) { events = ALL_EVENTS; }\n    changes.forEach(function (change) {\n        // skip unwanted change types\n        if (events.indexOf(change.type) > -1) {\n            current = processIndividualChange(current, change);\n        }\n    });\n    return current;\n}\n/**\n * Create an operator that allows you to compare the current emission with\n * the prior, even on first emission (where prior is undefined).\n */\nvar windowwise = function () {\n    return pipe(startWith(undefined), pairwise());\n};\n/**\n * Given two snapshots does their metadata match?\n * @param a\n * @param b\n */\nvar metaDataEquals = function (a, b) { return JSON.stringify(a.metadata) === JSON.stringify(b.metadata); };\n/**\n * Create an operator that filters out empty changes. We provide the\n * ability to filter on events, which means all changes can be filtered out.\n * This creates an empty array and would be incorrect to emit.\n */\nvar filterEmptyUnlessFirst = function () {\n    return pipe(windowwise(), filter(function (_a) {\n        var prior = _a[0], current = _a[1];\n        return current.length > 0 || prior === undefined;\n    }), map(function (_a) {\n        var _ = _a[0], current = _a[1];\n        return current;\n    }));\n};\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\nexport function collectionChanges(query, options) {\n    if (options === void 0) { options = {}; }\n    return fromRef(query, { includeMetadataChanges: true }).pipe(windowwise(), map(function (_a) {\n        var priorSnapshot = _a[0], currentSnapshot = _a[1];\n        var docChanges = currentSnapshot.docChanges();\n        if (priorSnapshot && !metaDataEquals(priorSnapshot, currentSnapshot)) {\n            // the metadata has changed, docChanges() doesn't return metadata events, so let's\n            // do it ourselves by scanning over all the docs and seeing if the metadata has changed\n            // since either this docChanges() emission or the prior snapshot\n            currentSnapshot.docs.forEach(function (currentDocSnapshot, currentIndex) {\n                var currentDocChange = docChanges.find(function (c) {\n                    return refEqual(c.doc.ref, currentDocSnapshot.ref);\n                });\n                if (currentDocChange) {\n                    // if the doc is in the current changes and the metadata hasn't changed this doc\n                    if (metaDataEquals(currentDocChange.doc, currentDocSnapshot)) {\n                        return;\n                    }\n                }\n                else {\n                    // if there is a prior doc and the metadata hasn't changed skip this doc\n                    var priorDocSnapshot = priorSnapshot === null || priorSnapshot === void 0 ? void 0 : priorSnapshot.docs.find(function (d) {\n                        return refEqual(d.ref, currentDocSnapshot.ref);\n                    });\n                    if (priorDocSnapshot &&\n                        metaDataEquals(priorDocSnapshot, currentDocSnapshot)) {\n                        return;\n                    }\n                }\n                docChanges.push({\n                    oldIndex: currentIndex,\n                    newIndex: currentIndex,\n                    type: 'modified',\n                    doc: currentDocSnapshot\n                });\n            });\n        }\n        return docChanges;\n    }), filterEvents(options.events || ALL_EVENTS), filterEmptyUnlessFirst());\n}\n/**\n * Return a stream of document snapshots on a query. These results are in sort order.\n * @param query\n */\nexport function collection(query) {\n    return fromRef(query, { includeMetadataChanges: true }).pipe(map(function (changes) { return changes.docs; }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\nexport function sortedChanges(query, options) {\n    if (options === void 0) { options = {}; }\n    return collectionChanges(query, options).pipe(scan(function (current, changes) {\n        return processDocumentChanges(current, changes, options.events);\n    }, []), distinctUntilChanged());\n}\n/**\n * Create a stream of changes as they occur it time. This method is similar\n * to docChanges() but it collects each event in an array over time.\n */\nexport function auditTrail(query, options) {\n    if (options === void 0) { options = {}; }\n    return collectionChanges(query, options).pipe(scan(function (current, action) { return __spreadArray(__spreadArray([], current), action); }, []));\n}\n/**\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\n * @param query\n */\nexport function collectionData(query, options) {\n    if (options === void 0) { options = {}; }\n    return collection(query).pipe(map(function (arr) {\n        return arr.map(function (snap) { return snapToData(snap, options); });\n    }));\n}\n"]},"metadata":{},"sourceType":"module"}