{"ast":null,"code":"import { parseDataUrlContent } from './util';\nconst cache = {};\n\nfunction getCacheKey(url) {\n  let key = url.replace(/\\?.*/, ''); // font resourse\n\n  if (/ttf|otf|eot|woff2?/i.test(key)) {\n    key = key.replace(/.*\\//, '');\n  }\n\n  return key;\n}\n\nexport function getBlobFromURL(url, options) {\n  const cacheKey = getCacheKey(url);\n\n  if (cache[cacheKey] != null) {\n    return cache[cacheKey];\n  } // cache bypass so we dont have CORS issues with cached images\n  // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n\n\n  if (options.cacheBust) {\n    // eslint-disable-next-line no-param-reassign\n    url += (/\\?/.test(url) ? '&' : '?') + new Date().getTime();\n  }\n\n  const failed = reason => {\n    let placeholder = '';\n\n    if (options.imagePlaceholder) {\n      const parts = options.imagePlaceholder.split(/,/);\n\n      if (parts && parts[1]) {\n        placeholder = parts[1];\n      }\n    }\n\n    let msg = `Failed to fetch resource: ${url}`;\n\n    if (reason) {\n      msg = typeof reason === 'string' ? reason : reason.message;\n    }\n\n    if (msg) {\n      console.error(msg);\n    }\n\n    return {\n      blob: placeholder,\n      contentType: ''\n    };\n  };\n\n  const deferred = window.fetch(url).then(res => // eslint-disable-next-line promise/no-nesting\n  res.blob().then(blob => ({\n    blob,\n    contentType: res.headers.get('Content-Type') || ''\n  }))).then(_ref => {\n    let {\n      blob,\n      contentType\n    } = _ref;\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onloadend = () => resolve({\n        contentType,\n        blob: reader.result\n      });\n\n      reader.onerror = reject;\n      reader.readAsDataURL(blob);\n    });\n  }).then(_ref2 => {\n    let {\n      blob,\n      contentType\n    } = _ref2;\n    return {\n      contentType,\n      blob: parseDataUrlContent(blob)\n    };\n  }) // on failed\n  .catch(failed); // cache result\n\n  cache[cacheKey] = deferred;\n  return deferred;\n}","map":{"version":3,"sources":["../src/getBlobFromURL.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { parseDataUrlContent } from './util';\nconst cache = {};\nfunction getCacheKey(url) {\n    let key = url.replace(/\\?.*/, '');\n    // font resourse\n    if (/ttf|otf|eot|woff2?/i.test(key)) {\n        key = key.replace(/.*\\//, '');\n    }\n    return key;\n}\nexport function getBlobFromURL(url, options) {\n    const cacheKey = getCacheKey(url);\n    if (cache[cacheKey] != null) {\n        return cache[cacheKey];\n    }\n    // cache bypass so we dont have CORS issues with cached images\n    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n    if (options.cacheBust) {\n        // eslint-disable-next-line no-param-reassign\n        url += (/\\?/.test(url) ? '&' : '?') + new Date().getTime();\n    }\n    const failed = (reason) => {\n        let placeholder = '';\n        if (options.imagePlaceholder) {\n            const parts = options.imagePlaceholder.split(/,/);\n            if (parts && parts[1]) {\n                placeholder = parts[1];\n            }\n        }\n        let msg = `Failed to fetch resource: ${url}`;\n        if (reason) {\n            msg = typeof reason === 'string' ? reason : reason.message;\n        }\n        if (msg) {\n            console.error(msg);\n        }\n        return {\n            blob: placeholder,\n            contentType: '',\n        };\n    };\n    const deferred = window\n        .fetch(url)\n        .then((res) => \n    // eslint-disable-next-line promise/no-nesting\n    res.blob().then((blob) => ({\n        blob,\n        contentType: res.headers.get('Content-Type') || '',\n    })))\n        .then(({ blob, contentType }) => new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onloadend = () => resolve({\n            contentType,\n            blob: reader.result,\n        });\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    }))\n        .then(({ blob, contentType }) => ({\n        contentType,\n        blob: parseDataUrlContent(blob),\n    }))\n        // on failed\n        .catch(failed);\n    // cache result\n    cache[cacheKey] = deferred;\n    return deferred;\n}\n//# sourceMappingURL=getBlobFromURL.js.map"]},"metadata":{},"sourceType":"module"}