{"ast":null,"code":"\"use strict\";\n\nvar zlib = require('zlib');\n\nvar crc32 = require('./crc32');\n\nvar PNG_HEAD = new Buffer.from([137, 80, 78, 71, 13, 10, 26, 10]);\nvar PNG_IHDR = new Buffer.from([0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 0, 0, 0, 0, 0, 8, 3, 0, 0, 0, 0, 0, 0, 0]); // PNG_IHDR[17] = 3, meaning Index color\n\nvar PNG_IDAT = new Buffer.from([0, 0, 0, 0, 73, 68, 65, 84]);\nvar PNG_IEND = new Buffer.from([0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130]); // Palette chunk for indexed color image. \n// PNG_PLTE[8,9,10] = R,G,B of color #0 (Foreground); default = [0,0,0] i.e. black\n// PNG_PLTE[11,12,13] = R,G,B of color #1 (Background) default = [255,255,255] i.e. white\n\nvar PNG_PLTE = new Buffer.from([0, 0, 0, 6, 0x50, 0x4c, 0x54, 0x45, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0]); // Transparency chunk for indexed color image.\n// PNG_tRNS[8]=transparency of color #0\n// PNG_tRNS[9]=transparency of color #1\n\nvar PNG_tRNS = new Buffer.from([0, 0, 0, 2, 0x74, 0x52, 0x4e, 0x53, 0xff, 0x00, 0, 0, 0, 0]);\n\nfunction png(bitmap, stream, foreColor, backColor, transparent) {\n  stream.push(PNG_HEAD);\n  var IHDR = Buffer.concat([PNG_IHDR]);\n  IHDR.writeUInt32BE(bitmap.size, 8);\n  IHDR.writeUInt32BE(bitmap.size, 12);\n  IHDR.writeUInt32BE(crc32(IHDR.slice(4, -4)), 21);\n  stream.push(IHDR); // Pallete chunk\n\n  var PLTE = Buffer.concat([PNG_PLTE]);\n  if (foreColor) foreColor.copy(PLTE, 8);\n  if (backColor) backColor.copy(PLTE, 11);\n  PLTE.writeUInt32BE(crc32(PLTE.slice(4, -4)), PLTE.length - 4);\n  stream.push(PLTE);\n\n  if (transparent) {\n    var tRNS = Buffer.concat([PNG_tRNS]);\n    tRNS.writeUInt32BE(crc32(tRNS.slice(4, -4)), tRNS.length - 4);\n    stream.push(tRNS);\n  }\n\n  var IDAT = Buffer.concat([PNG_IDAT, zlib.deflateSync(bitmap.data, {\n    level: 9\n  }), new Buffer.alloc(4)]);\n  IDAT.writeUInt32BE(IDAT.length - 12, 0);\n  IDAT.writeUInt32BE(crc32(IDAT.slice(4, -4)), IDAT.length - 4);\n  stream.push(IDAT);\n  stream.push(PNG_IEND);\n  stream.push(null);\n}\n\nfunction bitmap(matrix, size, margin) {\n  var N = matrix.length;\n  var X = (N + 2 * margin) * size;\n  var data = new Buffer.alloc((X + 1) * X);\n  data.fill(1); // We are writing color INDEX now, not gray value! (Was: data.fill(255); )\n\n  for (var i = 0; i < X; i++) {\n    data[i * (X + 1)] = 0;\n  }\n\n  for (var i = 0; i < N; i++) {\n    for (var j = 0; j < N; j++) {\n      if (matrix[i][j]) {\n        var offset = ((margin + i) * (X + 1) + (margin + j)) * size + 1;\n        data.fill(0, offset, offset + size);\n\n        for (var c = 1; c < size; c++) {\n          data.copy(data, offset + c * (X + 1), offset, offset + size);\n        }\n      }\n    }\n  }\n\n  return {\n    data: data,\n    size: X\n  };\n}\n\nmodule.exports = {\n  bitmap: bitmap,\n  png: png\n};","map":{"version":3,"sources":["/home/juano/reactProjects/Novo-Lab-Clinico/node_modules/qr-image-color/lib/png.js"],"names":["zlib","require","crc32","PNG_HEAD","Buffer","from","PNG_IHDR","PNG_IDAT","PNG_IEND","PNG_PLTE","PNG_tRNS","png","bitmap","stream","foreColor","backColor","transparent","push","IHDR","concat","writeUInt32BE","size","slice","PLTE","copy","length","tRNS","IDAT","deflateSync","data","level","alloc","matrix","margin","N","X","fill","i","j","offset","c","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nvar zlib = require('zlib');\r\n\r\nvar crc32 = require('./crc32');\r\n\r\nvar PNG_HEAD  = new Buffer.from([137,80,78,71,13,10,26,10]);\r\nvar PNG_IHDR  = new Buffer.from([0,0,0,13,73,72,68,82,0,0,0,0,0,0,0,0,8,3,0,0,0,0,0,0,0]);  // PNG_IHDR[17] = 3, meaning Index color\r\nvar PNG_IDAT  = new Buffer.from([0,0,0,0,73,68,65,84]);\r\nvar PNG_IEND  = new Buffer.from([0,0,0,0,73,69,78,68,174,66,96,130]);\r\n\r\n// Palette chunk for indexed color image. \r\n// PNG_PLTE[8,9,10] = R,G,B of color #0 (Foreground); default = [0,0,0] i.e. black\r\n// PNG_PLTE[11,12,13] = R,G,B of color #1 (Background) default = [255,255,255] i.e. white\r\nvar PNG_PLTE  = new Buffer.from([0,0,0,6,0x50,0x4c,0x54,0x45,0,0,0,255,255,255,0,0,0,0]);\r\n\r\n// Transparency chunk for indexed color image.\r\n// PNG_tRNS[8]=transparency of color #0\r\n// PNG_tRNS[9]=transparency of color #1\r\nvar PNG_tRNS  = new Buffer.from([0,0,0,2,0x74,0x52,0x4e,0x53,0xff,0x00,0,0,0,0]);\r\n\r\nfunction png(bitmap, stream, foreColor, backColor, transparent) {\r\n    stream.push(PNG_HEAD);\r\n\r\n    var IHDR = Buffer.concat([PNG_IHDR]);\r\n    IHDR.writeUInt32BE(bitmap.size, 8);\r\n    IHDR.writeUInt32BE(bitmap.size, 12);\r\n    IHDR.writeUInt32BE(crc32(IHDR.slice(4, -4)), 21);\r\n    stream.push(IHDR);\r\n\r\n    // Pallete chunk\r\n    var PLTE = Buffer.concat([PNG_PLTE]);\r\n    if (foreColor) foreColor.copy(PLTE,  8);\r\n    if (backColor) backColor.copy(PLTE, 11);\r\n    PLTE.writeUInt32BE(crc32(PLTE.slice(4, -4)), PLTE.length - 4);\r\n    stream.push(PLTE);\r\n\r\n    if (transparent){\r\n        var tRNS = Buffer.concat([PNG_tRNS]);\r\n        tRNS.writeUInt32BE(crc32(tRNS.slice(4, -4)), tRNS.length - 4);\r\n        stream.push(tRNS);\r\n    }\r\n\r\n    var IDAT = Buffer.concat([\r\n        PNG_IDAT,\r\n        zlib.deflateSync(bitmap.data, { level: 9 }),\r\n        new Buffer.alloc(4)\r\n    ]);\r\n    IDAT.writeUInt32BE(IDAT.length - 12, 0);\r\n    IDAT.writeUInt32BE(crc32(IDAT.slice(4, -4)), IDAT.length - 4);\r\n    stream.push(IDAT);\r\n\r\n    stream.push(PNG_IEND);\r\n    stream.push(null);\r\n}\r\n\r\nfunction bitmap(matrix, size, margin) {\r\n    var N = matrix.length;\r\n    var X = (N + 2 * margin) * size;\r\n    var data = new Buffer.alloc((X + 1) * X);\r\n    data.fill(1);   // We are writing color INDEX now, not gray value! (Was: data.fill(255); )\r\n    for (var i = 0; i < X; i++) {\r\n        data[i * (X + 1)] = 0;\r\n    }\r\n\r\n    for (var i = 0; i < N; i++) {\r\n        for (var j = 0; j < N; j++) {\r\n            if (matrix[i][j]) {\r\n                var offset = ((margin + i) * (X + 1) + (margin + j)) * size + 1;\r\n                data.fill(0, offset, offset + size);\r\n                for (var c = 1; c < size; c++) {\r\n                    data.copy(data, offset + c * (X + 1), offset, offset + size);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        data: data,\r\n        size: X\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    bitmap: bitmap,\r\n    png: png\r\n}\r\n"]},"metadata":{},"sourceType":"script"}