{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { getBlobFromURL } from './getBlobFromURL';\nimport { getMimeType, isDataUrl, makeDataUrl, resolveUrl } from './util';\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"'])([^\"']+)\\1\\)/g;\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nexport function toRegex(url) {\n  // eslint-disable-next-line no-useless-escape\n  const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n  return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g');\n}\nexport function parseURLs(cssText) {\n  const result = [];\n  cssText.replace(URL_REGEX, (raw, quotation, url) => {\n    result.push(url);\n    return raw;\n  });\n  return result.filter(url => !isDataUrl(url));\n}\nexport function embed(cssText, resourceURL, baseURL, options, get) {\n  const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;\n  return Promise.resolve(resolvedURL).then(url => get ? get(url) : getBlobFromURL(url, options)).then(data => {\n    if (typeof data === 'string') {\n      return makeDataUrl(data, getMimeType(resourceURL));\n    }\n\n    return makeDataUrl(data.blob, getMimeType(resourceURL) || data.contentType);\n  }).then(dataURL => cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`)).then(content => content, () => resolvedURL);\n}\n\nfunction filterPreferredFontFormat(str, _ref) {\n  let {\n    preferredFontFormat\n  } = _ref;\n  return !preferredFontFormat ? str : str.replace(FONT_SRC_REGEX, match => {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const [src,, format] = URL_WITH_FORMAT_REGEX.exec(match) || [];\n\n      if (!format) {\n        return '';\n      }\n\n      if (format === preferredFontFormat) {\n        return `src: ${src};`;\n      }\n    }\n  });\n}\n\nexport function shouldEmbed(url) {\n  return url.search(URL_REGEX) !== -1;\n}\nexport function embedResources(cssText, baseUrl, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!shouldEmbed(cssText)) {\n      return Promise.resolve(cssText);\n    }\n\n    const filteredCSSText = filterPreferredFontFormat(cssText, options);\n    return Promise.resolve(filteredCSSText).then(parseURLs).then(urls => urls.reduce((deferred, url) => // eslint-disable-next-line promise/no-nesting\n    deferred.then(css => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText)));\n  });\n}","map":{"version":3,"sources":["../src/embedResources.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAAS,cAAT,QAA+B,kBAA/B;AACA,SAAS,WAAT,EAAsB,SAAtB,EAAiC,WAAjC,EAA8C,UAA9C,QAAgE,QAAhE;AAEA,MAAM,SAAS,GAAG,4BAAlB;AACA,MAAM,qBAAqB,GAAG,4CAA9B;AACA,MAAM,cAAc,GAAG,oDAAvB;AAEA,OAAM,SAAU,OAAV,CAAkB,GAAlB,EAA6B;AACjC;AACA,QAAM,OAAO,GAAG,GAAG,CAAC,OAAJ,CAAY,0BAAZ,EAAwC,MAAxC,CAAhB;AACA,SAAO,IAAI,MAAJ,CAAW,iBAAiB,OAAO,aAAnC,EAAkD,GAAlD,CAAP;AACD;AAED,OAAM,SAAU,SAAV,CAAoB,OAApB,EAAmC;AACvC,QAAM,MAAM,GAAa,EAAzB;AAEA,EAAA,OAAO,CAAC,OAAR,CAAgB,SAAhB,EAA2B,CAAC,GAAD,EAAM,SAAN,EAAiB,GAAjB,KAAwB;AACjD,IAAA,MAAM,CAAC,IAAP,CAAY,GAAZ;AACA,WAAO,GAAP;AACD,GAHD;AAKA,SAAO,MAAM,CAAC,MAAP,CAAe,GAAD,IAAS,CAAC,SAAS,CAAC,GAAD,CAAjC,CAAP;AACD;AAED,OAAM,SAAU,KAAV,CACJ,OADI,EAEJ,WAFI,EAGJ,OAHI,EAIJ,OAJI,EAKJ,GALI,EAKkC;AAEtC,QAAM,WAAW,GAAG,OAAO,GAAG,UAAU,CAAC,WAAD,EAAc,OAAd,CAAb,GAAsC,WAAjE;AAEA,SAAO,OAAO,CAAC,OAAR,CAAgB,WAAhB,EACJ,IADI,CACkD,GAAD,IACpD,GAAG,GAAG,GAAG,CAAC,GAAD,CAAN,GAAc,cAAc,CAAC,GAAD,EAAM,OAAN,CAF5B,EAIJ,IAJI,CAIE,IAAD,IAAS;AACb,QAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,aAAO,WAAW,CAAC,IAAD,EAAO,WAAW,CAAC,WAAD,CAAlB,CAAlB;AACD;;AAED,WAAO,WAAW,CAChB,IAAI,CAAC,IADW,EAEhB,WAAW,CAAC,WAAD,CAAX,IAA4B,IAAI,CAAC,WAFjB,CAAlB;AAID,GAbI,EAcJ,IAdI,CAcE,OAAD,IAAa,OAAO,CAAC,OAAR,CAAgB,OAAO,CAAC,WAAD,CAAvB,EAAsC,KAAK,OAAO,IAAlD,CAdd,EAeJ,IAfI,CAgBF,OAAD,IAAa,OAhBV,EAiBH,MAAM,WAjBH,CAAP;AAmBD;;AAED,SAAS,yBAAT,CACE,GADF,QAEkC;AAAA,MAAhC;AAAE,IAAA;AAAF,GAAgC;AAEhC,SAAO,CAAC,mBAAD,GACH,GADG,GAEH,GAAG,CAAC,OAAJ,CAAY,cAAZ,EAA6B,KAAD,IAAkB;AAC5C;AACA,WAAO,IAAP,EAAa;AACX,YAAM,CAAC,GAAD,GAAQ,MAAR,IAAkB,qBAAqB,CAAC,IAAtB,CAA2B,KAA3B,KAAqC,EAA7D;;AAEA,UAAI,CAAC,MAAL,EAAa;AACX,eAAO,EAAP;AACD;;AAED,UAAI,MAAM,KAAK,mBAAf,EAAoC;AAClC,eAAO,QAAQ,GAAG,GAAlB;AACD;AACF;AACF,GAbD,CAFJ;AAgBD;;AAED,OAAM,SAAU,WAAV,CAAsB,GAAtB,EAAiC;AACrC,SAAO,GAAG,CAAC,MAAJ,CAAW,SAAX,MAA0B,CAAC,CAAlC;AACD;AAED,OAAM,SAAgB,cAAhB,CACJ,OADI,EAEJ,OAFI,EAGJ,OAHI,EAGY;;AAEhB,QAAI,CAAC,WAAW,CAAC,OAAD,CAAhB,EAA2B;AACzB,aAAO,OAAO,CAAC,OAAR,CAAgB,OAAhB,CAAP;AACD;;AAED,UAAM,eAAe,GAAG,yBAAyB,CAAC,OAAD,EAAU,OAAV,CAAjD;AACA,WAAO,OAAO,CAAC,OAAR,CAAgB,eAAhB,EACJ,IADI,CACC,SADD,EAEJ,IAFI,CAEE,IAAD,IACJ,IAAI,CAAC,MAAL,CACE,CAAC,QAAD,EAAW,GAAX,KACE;AACA,IAAA,QAAQ,CAAC,IAAT,CAAe,GAAD,IAAS,KAAK,CAAC,GAAD,EAAM,GAAN,EAAW,OAAX,EAAoB,OAApB,CAA5B,CAHJ,EAIE,OAAO,CAAC,OAAR,CAAgB,eAAhB,CAJF,CAHG,CAAP;AAUD,G;AAAA","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getBlobFromURL } from './getBlobFromURL';\nimport { getMimeType, isDataUrl, makeDataUrl, resolveUrl } from './util';\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"'])([^\"']+)\\1\\)/g;\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nexport function toRegex(url) {\n    // eslint-disable-next-line no-useless-escape\n    const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n    return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g');\n}\nexport function parseURLs(cssText) {\n    const result = [];\n    cssText.replace(URL_REGEX, (raw, quotation, url) => {\n        result.push(url);\n        return raw;\n    });\n    return result.filter((url) => !isDataUrl(url));\n}\nexport function embed(cssText, resourceURL, baseURL, options, get) {\n    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;\n    return Promise.resolve(resolvedURL)\n        .then((url) => get ? get(url) : getBlobFromURL(url, options))\n        .then((data) => {\n        if (typeof data === 'string') {\n            return makeDataUrl(data, getMimeType(resourceURL));\n        }\n        return makeDataUrl(data.blob, getMimeType(resourceURL) || data.contentType);\n    })\n        .then((dataURL) => cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`))\n        .then((content) => content, () => resolvedURL);\n}\nfunction filterPreferredFontFormat(str, { preferredFontFormat }) {\n    return !preferredFontFormat\n        ? str\n        : str.replace(FONT_SRC_REGEX, (match) => {\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];\n                if (!format) {\n                    return '';\n                }\n                if (format === preferredFontFormat) {\n                    return `src: ${src};`;\n                }\n            }\n        });\n}\nexport function shouldEmbed(url) {\n    return url.search(URL_REGEX) !== -1;\n}\nexport function embedResources(cssText, baseUrl, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!shouldEmbed(cssText)) {\n            return Promise.resolve(cssText);\n        }\n        const filteredCSSText = filterPreferredFontFormat(cssText, options);\n        return Promise.resolve(filteredCSSText)\n            .then(parseURLs)\n            .then((urls) => urls.reduce((deferred, url) => \n        // eslint-disable-next-line promise/no-nesting\n        deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText)));\n    });\n}\n//# sourceMappingURL=embedResources.js.map"]},"metadata":{},"sourceType":"module"}